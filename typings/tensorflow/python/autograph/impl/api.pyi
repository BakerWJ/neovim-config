from tensorflow.python.autograph.core import ag_ctx as ag_ctx, converter as converter
from tensorflow.python.autograph.impl import conversion as conversion
from tensorflow.python.autograph.operators import py_builtins as py_builtins
from tensorflow.python.autograph.pyct import error_utils as error_utils, errors as errors, inspect_utils as inspect_utils, origin_info as origin_info
from tensorflow.python.eager import function as function
from tensorflow.python.framework import errors_impl as errors_impl
from tensorflow.python.util import tf_decorator as tf_decorator, tf_inspect as tf_inspect, tf_stack as tf_stack
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

def is_autograph_strict_conversion_mode(): ...

class AutoGraphError(errors.PyCTError): ...
class ConversionError(AutoGraphError): ...
class StagingError(AutoGraphError): ...

class _ErrorMetadata(error_utils.ErrorMetadataBase):
    def create_exception(self, source_error: Any): ...

class StackTraceMapper(tf_stack.StackTraceMapper):
    def __init__(self, converted_fn: Any) -> None: ...
    def get_effective_source_map(self): ...

def autograph_artifact(entity: Any, extras: Optional[Any] = ...): ...
def is_autograph_artifact(entity: Any): ...
def tf_convert(f: Any, ctx: Any, convert_by_default: bool = ..., user_requested: bool = ...): ...
def convert(recursive: bool = ..., optional_features: Optional[Any] = ..., user_requested: bool = ..., conversion_ctx: Any = ...): ...
def call_with_unspecified_conversion_status(func: Any): ...
def do_not_convert(func: Optional[Any] = ...): ...
def converted_call(f: Any, args: Any, kwargs: Any, caller_fn_scope: Optional[Any] = ..., options: Optional[Any] = ...): ...
def to_graph(entity: Any, recursive: bool = ..., experimental_optional_features: Optional[Any] = ...): ...
def to_graph_v1(entity: Any, recursive: bool = ..., arg_values: Optional[Any] = ..., arg_types: Optional[Any] = ..., experimental_optional_features: Optional[Any] = ...): ...
def to_code_v1(entity: Any, recursive: bool = ..., arg_values: Optional[Any] = ..., arg_types: Optional[Any] = ..., indentation: str = ..., experimental_optional_features: Optional[Any] = ...): ...
def to_code(entity: Any, recursive: bool = ..., experimental_optional_features: Optional[Any] = ...): ...

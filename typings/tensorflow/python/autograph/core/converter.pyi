import enum
from tensorflow.python.autograph.pyct import anno as anno, ast_util as ast_util, cfg as cfg, parser as parser, qual_names as qual_names, templates as templates, transformer as transformer
from tensorflow.python.autograph.pyct.static_analysis import activity as activity, liveness as liveness, reaching_definitions as reaching_definitions
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

class Feature(enum.Enum):
    ALL: str = ...
    AUTO_CONTROL_DEPS: str = ...
    ASSERT_STATEMENTS: str = ...
    BUILTIN_FUNCTIONS: str = ...
    EQUALITY_OPERATORS: str = ...
    LISTS: str = ...
    NAME_SCOPES: str = ...
    @classmethod
    def all(cls): ...
    @classmethod
    def all_but(cls, exclude: Any): ...

STANDARD_OPTIONS: Any

class ConversionOptions:
    recursive: Any = ...
    user_requested: Any = ...
    internal_convert_user_code: Any = ...
    optional_features: Any = ...
    def __init__(self, recursive: bool = ..., user_requested: bool = ..., internal_convert_user_code: bool = ..., optional_features: Any = ...) -> None: ...
    def as_tuple(self): ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def uses(self, feature: Any): ...
    def call_options(self): ...
    def to_ast(self): ...

class ProgramContext: ...

class EntityContext(transformer.Context):
    namer: Any = ...
    program: Any = ...
    target_name: Any = ...
    def __init__(self, namer: Any, entity_info: Any, program_ctx: Any, target_name: Optional[Any] = ...) -> None: ...

class Base(transformer.Base):
    def __init__(self, ctx: Any) -> None: ...
    def get_definition_directive(self, node: Any, directive: Any, arg: Any, default: Any): ...
    def visit(self, node: Any): ...

class AnnotatedDef(reaching_definitions.Definition):
    directives: Any = ...
    def __init__(self) -> None: ...

def standard_analysis(node: Any, context: Any, is_initial: bool = ...): ...
def apply_(node: Any, context: Any, converter_module: Any): ...

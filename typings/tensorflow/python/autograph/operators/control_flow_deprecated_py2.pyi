from tensorflow.python.autograph.operators import py_builtins as py_builtins, special_values as special_values
from tensorflow.python.autograph.utils import ag_logging as ag_logging, misc as misc, tensors as tensors
from tensorflow.python.data.experimental.ops import scan_ops as scan_ops, take_while_ops as take_while_ops
from tensorflow.python.data.ops import dataset_ops as dataset_ops, iterator_ops as iterator_ops
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, func_graph as func_graph, ops as ops, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, math_ops as math_ops, tensor_array_ops as tensor_array_ops
from tensorflow.python.ops.ragged import ragged_tensor as ragged_tensor
from tensorflow.python.util import lazy_loader as lazy_loader, nest as nest
from typing import Any

input_lib: Any
LIMIT_PYTHON_ITERATIONS: bool
PYTHON_MAX_ITERATIONS: int
WARN_INEFFICIENT_UNROLL: bool
INEFFICIENT_UNROLL_MIN_ITERATIONS: int
INEFFICIENT_UNROLL_MIN_OPS: int

def for_stmt(iter_: Any, extra_test: Any, body: Any, get_state: Any, set_state: Any, init_vars: Any, basic_symbol_names: Any, composite_symbol_names: Any, opts: Any): ...
def while_stmt(test: Any, body: Any, get_state: Any, set_state: Any, init_vars: Any, basic_symbol_names: Any, composite_symbol_names: Any, opts: Any): ...

class _PythonLoopChecker:
    iterations: int = ...
    check_inefficient_unroll: Any = ...
    check_op_count_after_iteration: bool = ...
    def __init__(self) -> None: ...
    ops_before_iteration: Any = ...
    def before_iteration(self) -> None: ...
    def after_iteration(self) -> None: ...

def if_stmt(cond: Any, body: Any, orelse: Any, get_state: Any, set_state: Any, basic_symbol_names: Any, composite_symbol_names: Any): ...
def tf_if_stmt(cond: Any, body: Any, orelse: Any, get_state: Any, set_state: Any, basic_symbol_names: Any, composite_symbol_names: Any): ...

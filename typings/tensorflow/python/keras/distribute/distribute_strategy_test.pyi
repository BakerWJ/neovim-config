from absl.testing import parameterized
from tensorflow.python import keras as keras
from tensorflow.python.data.experimental.ops import cardinality as cardinality
from tensorflow.python.data.ops import dataset_ops as dataset_ops
from tensorflow.python.distribute import combinations as combinations, distribution_strategy_context as distribution_strategy_context, mirrored_strategy as mirrored_strategy, parameter_server_strategy as parameter_server_strategy, reduce_util as reduce_util, strategy_combinations as strategy_combinations, tpu_strategy as tpu_strategy
from tensorflow.python.eager import backprop as backprop, context as context, def_function as def_function
from tensorflow.python.framework import sparse_tensor as sparse_tensor
from tensorflow.python.keras import testing_utils as testing_utils
from tensorflow.python.keras.distribute import distributed_training_utils as distributed_training_utils
from tensorflow.python.keras.engine import base_layer_utils as base_layer_utils
from tensorflow.python.keras.mixed_precision.experimental import policy as policy
from tensorflow.python.keras.utils import np_utils as np_utils
from tensorflow.python.ops import array_ops as array_ops, check_ops as check_ops, math_ops as math_ops, nn as nn, variables as variables
from tensorflow.python.ops.losses import loss_reduction as loss_reduction
from tensorflow.python.ops.ragged import ragged_tensor as ragged_tensor
from tensorflow.python.platform import test as test
from tensorflow.python.training import gradient_descent as gradient_descent, rmsprop as rmsprop
from tensorflow.python.util import nest as nest
from typing import Any, Optional

def simple_sequential_model(): ...
def simple_subclassed_model(num_labels: Any = ...): ...
def simple_multi_inputs_multi_outputs_model(): ...
def get_multi_inputs_multi_outputs_data(): ...
def batch_wrapper(dataset: Any, batch_size: Any, distribution: Any, repeat: Optional[Any] = ...): ...
def get_model(): ...
def get_sample_weights_model(): ...
def get_dataset(distribution: Any): ...
def get_predict_dataset(distribution: Any): ...
def convert_numpy_to_dataset_with_unknown_cardinality(inputs: Any, targets: Optional[Any] = ...): ...
def multi_input_output_model(): ...

strategies_minus_default_minus_tpu: Any
strategies_minus_tpu: Any
tpu_strategies: Any

def strategy_minus_tpu_combinations(): ...
def tpu_strategy_combinations(): ...
def tpu_strategy_combinations_graph_only(): ...
def all_strategy_combinations(): ...
def all_strategy_combinations_plus_run_distributed(): ...
def all_strategy_minus_default_and_tpu_combinations(): ...
def all_strategy_combinations_minus_default(): ...
def strategy_and_optimizer_combinations(): ...

class TestDistributionStrategyWithNumpyArrays(test.TestCase, parameterized.TestCase):
    def test_calculating_input_params_no_steps_no_batch_size(self, distribution: Any) -> None: ...
    def test_calculating_input_params_with_steps_no_batch_size(self, distribution: Any) -> None: ...
    def test_calculating_input_params_no_steps_with_batch_size(self, distribution: Any) -> None: ...
    def test_calculating_input_params_with_steps_with_batch_size(self, distribution: Any) -> None: ...
    def test_calling_model_with_numpy_arrays(self, distribution: Any) -> None: ...
    def test_calling_model_with_mixed_precision(self, distribution: Any) -> None: ...
    v1: Any = ...
    v2: Any = ...
    def test_operator_overload_mixed_precision(self, distribution: Any): ...
    def test_optimizer_in_cross_replica_context_raises_error(self, distribution: Any) -> None: ...
    def test_calling_model_with_nested_numpy_arrays(self, distribution: Any) -> None: ...
    def test_numpy_with_sample_weights(self, distribution: Any) -> None: ...
    def test_flatten_predict_outputs(self, distribution: Any) -> None: ...
    def test_evaluate_with_partial_batch(self, distribution: Any, batch_size: Any) -> None: ...
    def test_predict_with_partial_batch(self, distribution: Any) -> None: ...
    def test_no_target_model(self, distribution: Any): ...
    def test_predict_multi_output_model_with_partial_batch(self, distribution: Any) -> None: ...
    extra_weight_1: Any = ...
    extra_weight_2: Any = ...
    def test_gradients_are_none(self, distribution: Any) -> None: ...

class TestDistributionStrategyWithDatasets(test.TestCase, parameterized.TestCase):
    def test_calling_model_on_same_dataset(self, distribution: Any) -> None: ...
    def test_model_interleaved_eval_same_as_direct_eval(self, distribution: Any) -> None: ...
    def test_fit_with_tuple_and_dict_dataset_inputs(self, distribution: Any) -> None: ...
    def test_fit_with_dictionary_in_the_dataset_b135161171(self, distribution: Any): ...
    def test_fit_eval_and_predict_methods_on_dataset_without_steps(self, distribution: Any) -> None: ...
    def test_on_dataset_with_unknown_cardinality_without_steps(self, distribution: Any, mode: Any) -> None: ...
    def test_on_dataset_with_unknown_cardinality(self, distribution: Any) -> None: ...
    def test_fit_eval_and_predict_methods_on_dataset(self, distribution: Any) -> None: ...
    def test_fit_eval_and_predict_with_optimizer(self, distribution: Any, optimizer: Any) -> None: ...
    def test_dataset_wrong_input_shape(self, distribution: Any, mode: Any) -> None: ...
    def test_dataset_external_batch_input_validation(self, distribution: Any) -> None: ...
    def test_learning_phase_value(self, distribution: Any) -> None: ...
    def testOptimizerWithCallbacks(self, distribution: Any): ...
    def test_evaluate_with_dataset_with_partial_batch(self, distribution: Any, batch_size: Any) -> None: ...
    def test_predict_with_dataset_with_partial_batch(self, distribution: Any) -> None: ...
    def test_predict_multi_output_model_with_dataset_with_partial_batch(self, distribution: Any) -> None: ...
    def test_match_model_input_matches_with_dataset_tensors(self, distribution: Any): ...
    def test_dataset_with_sample_weights(self, distribution: Any) -> None: ...

class TestRegularizerLoss(test.TestCase, parameterized.TestCase):
    class IdentityRegularizer(keras.regularizers.Regularizer):
        def __call__(self, x: Any): ...
    class AddLayer(keras.layers.Layer):
        v: Any = ...
        def build(self, _: Any) -> None: ...
        def call(self, inputs: Any): ...
    @staticmethod
    def loss_fn(_: Any, y_pred: Any): ...
    def test_regularizer_loss(self, distribution: Any) -> None: ...

class TestDistributionStrategyWithKerasModels(test.TestCase, parameterized.TestCase):
    def test_distribution_strategy_on_sequential_model(self, distribution: Any) -> None: ...
    def test_distribution_strategy_on_functional_model(self, distribution: Any) -> None: ...
    def test_distribution_strategy_one_dimensional(self, distribution: Any) -> None: ...
    def test_distribution_strategy_with_loss_reduction_types(self, distribution: Any, reduction: Any): ...
    def test_distribution_strategy_with_symbolic_add_loss(self, mode: Any, distribution: Any): ...
    def DISABLED_test_distribution_strategy_with_callable_add_loss(self, distribution: Any): ...
    bias: Any = ...
    def test_distribution_strategy_with_add_metric_in_call(self, distribution: Any): ...
    mean: Any = ...
    def test_distribution_strategy_with_add_metric_object(self, distribution: Any): ...
    def test_distribution_strategy_with_add_metric_outside_call(self, distribution: Any): ...
    def test_sparse_tensor_outputs(self, distribution: Any): ...
    def test_ragged_tensor_outputs(self, distribution: Any): ...
    def test_correctness_of_add_loss_with_merge_call(self, distribution: Any): ...

class TestDistributionStrategyWithMultipleAddLossAndMetricCalls(test.TestCase, parameterized.TestCase):
    def test_fit_and_evaluate(self, distribution: Any, model_fn: Any, l1: Any, l2: Any) -> None: ...

class DeterministicModel(keras.Model):
    x: Any = ...
    strategy: Any = ...
    def __init__(self, strategy: Any) -> None: ...
    def build(self, input_shape: Any) -> None: ...
    def call(self, inputs: Any, training: Optional[Any] = ..., mask: Optional[Any] = ...): ...

class TestModelCapturesStrategy(test.TestCase, parameterized.TestCase):
    def test_fit_and_evaluate(self, distribution: Any) -> None: ...

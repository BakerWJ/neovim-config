from tensorflow.python.eager import context as context
from tensorflow.python.framework import ops as ops
from tensorflow.python.ops import math_ops as math_ops, resource_variable_ops as resource_variable_ops, variables as variables
from typing import Any, Optional

class AutoCastVariable(variables.Variable):
    def __init__(self, variable: Any) -> None: ...
    @property
    def dtype(self): ...
    @property
    def true_dtype(self): ...
    def value(self): ...
    def read_value(self): ...
    def sparse_read(self, indices: Any, name: Optional[Any] = ...): ...
    def gather_nd(self, indices: Any, name: Optional[Any] = ...): ...
    def __getattr__(self, name: Any): ...
    def set_shape(self, shape: Any): ...
    @property
    def trainable(self): ...
    @property
    def synchronization(self): ...
    @property
    def aggregation(self): ...
    def eval(self, session: Optional[Any] = ...): ...
    def initialized_value(self): ...
    @property
    def initial_value(self): ...
    @property
    def constraint(self): ...
    def assign(self, value: Any, use_locking: Optional[Any] = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def assign_add(self, delta: Any, use_locking: Optional[Any] = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def assign_sub(self, delta: Any, use_locking: Optional[Any] = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def scatter_sub(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_add(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_max(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_min(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_mul(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_div(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_update(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def batch_scatter_update(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_nd_sub(self, indices: Any, updates: Any, name: Optional[Any] = ...): ...
    def scatter_nd_add(self, indices: Any, updates: Any, name: Optional[Any] = ...): ...
    def scatter_nd_update(self, indices: Any, updates: Any, name: Optional[Any] = ...): ...
    def load(self, value: Any, session: Optional[Any] = ...): ...
    @property
    def name(self): ...
    @property
    def initializer(self): ...
    @property
    def device(self): ...
    @property
    def op(self): ...
    @property
    def graph(self): ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...): ...
    def from_proto(self, variable_def: Any, import_scope: Optional[Any] = ...): ...
    def __add__(self, o: Any): ...
    def __radd__(self, o: Any): ...
    def __sub__(self, o: Any): ...
    def __rsub__(self, o: Any): ...
    def __mul__(self, o: Any): ...
    def __rmul__(self, o: Any): ...
    def __truediv__(self, o: Any): ...
    def __rtruediv__(self, o: Any): ...
    def __floordiv__(self, o: Any): ...
    def __rfloordiv__(self, o: Any): ...
    def __mod__(self, o: Any): ...
    def __rmod__(self, o: Any): ...
    def __lt__(self, o: Any) -> Any: ...
    def __le__(self, o: Any) -> Any: ...
    def __gt__(self, o: Any) -> Any: ...
    def __ge__(self, o: Any) -> Any: ...
    def __getitem__(self, o: Any): ...
    def __pow__(self, o: Any, modulo: Optional[Any] = ...): ...
    def __rpow__(self, o: Any): ...
    def __neg__(self): ...
    def __abs__(self): ...
    def __div__(self, o: Any): ...
    def __rdiv__(self, o: Any): ...
    def __matmul__(self, o: Any): ...
    def __rmatmul__(self, o: Any): ...

def create_autocast_variable(variable: Any): ...

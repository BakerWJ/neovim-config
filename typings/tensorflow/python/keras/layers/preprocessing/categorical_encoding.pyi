from tensorflow.python.framework import dtypes as dtypes, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_spec as tensor_spec
from tensorflow.python.keras.engine import base_preprocessing_layer as base_preprocessing_layer
from tensorflow.python.keras.utils import layer_utils as layer_utils
from tensorflow.python.ops import array_ops as array_ops, init_ops as init_ops, math_ops as math_ops, sparse_ops as sparse_ops
from tensorflow.python.ops.ragged import ragged_tensor as ragged_tensor
from tensorflow.python.util import compat as compat
from typing import Any, Optional

TFIDF: str
INT: str
BINARY: str
COUNT: str

class CategoricalEncoding(base_preprocessing_layer.CombinerPreprocessingLayer):
    num_elements: Any = ...
    tf_idf_weights: Any = ...
    def __init__(self, max_tokens: Optional[Any] = ..., output_mode: Any = ..., sparse: bool = ..., **kwargs: Any): ...
    def compute_output_shape(self, input_shape: Any): ...
    def compute_output_signature(self, input_spec: Any): ...
    def adapt(self, data: Any, reset_state: bool = ...) -> None: ...
    def get_config(self): ...
    def set_num_elements(self, num_elements: Any) -> None: ...
    def set_tfidf_data(self, tfidf_data: Any) -> None: ...
    def call(self, inputs: Any): ...

class _CategoricalEncodingAccumulator: ...

class _CategoricalEncodingCombiner(base_preprocessing_layer.Combiner):
    MAX_VALUE_IDX: int = ...
    DOC_ID_IDX: int = ...
    def __init__(self, compute_max_element: bool = ..., compute_idf: bool = ...) -> None: ...
    def compute(self, values: Any, accumulator: Optional[Any] = ...): ...
    def merge(self, accumulators: Any): ...
    def extract(self, accumulator: Any): ...
    def restore(self, output: Any) -> None: ...
    def serialize(self, accumulator: Any): ...
    def deserialize(self, encoded_accumulator: Any): ...

from tensorflow.python.distribute import distribution_strategy_context as distribution_strategy_context, input_lib as input_lib
from tensorflow.python.eager import context as context
from tensorflow.python.framework import constant_op as constant_op, errors as errors, ops as ops
from tensorflow.python.keras.engine import training_arrays as training_arrays, training_utils as training_utils
from tensorflow.python.keras.utils.generic_utils import Progbar as Progbar
from tensorflow.python.keras.utils.mode_keys import ModeKeys as ModeKeys
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops
from typing import Any, Optional

def experimental_tpu_fit_loop(model: Any, dataset: Any, epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., val_dataset: Optional[Any] = ..., validation_steps: Optional[Any] = ..., validation_freq: int = ...): ...
def experimental_tpu_test_loop(model: Any, dataset: Any, verbose: int = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ...): ...
def experimental_tpu_predict_loop(model: Any, dataset: Any, verbose: int = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ...): ...

class DistributionSingleWorkerTrainingLoop(training_utils.TrainingLoop):
    def fit(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_split: float = ..., validation_data: Optional[Any] = ..., shuffle: bool = ..., class_weight: Optional[Any] = ..., sample_weight: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., validation_steps: Optional[Any] = ..., validation_freq: int = ..., **kwargs: Any): ...
    def evaluate(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., verbose: int = ..., sample_weight: Optional[Any] = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., **kwargs: Any): ...
    def predict(self, model: Any, x: Any, batch_size: Optional[Any] = ..., verbose: int = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., **kwargs: Any): ...

class DistributionMultiWorkerTrainingLoop(training_utils.TrainingLoop):
    def __init__(self, single_worker_loop: Any) -> None: ...
    def fit(self, *args: Any, **kwargs: Any): ...
    def evaluate(self, *args: Any, **kwargs: Any): ...
    def predict(self, *args: Any, **kwargs: Any): ...

from tensorflow.python import tf2 as tf2
from tensorflow.python.distribute import distribution_strategy_context as distribution_strategy_context
from tensorflow.python.eager import context as context
from tensorflow.python.framework import dtypes as dtypes, ops as ops, tensor_shape as tensor_shape, tensor_util as tensor_util
from tensorflow.python.keras import backend as backend
from tensorflow.python.ops import array_ops as array_ops, control_flow_util as control_flow_util, control_flow_v2_func_graphs as control_flow_v2_func_graphs, init_ops as init_ops, init_ops_v2 as init_ops_v2
from tensorflow.python.util import nest as nest, tf_contextlib as tf_contextlib
from typing import Any, Optional

def create_mean_metric(value: Any, name: Optional[Any] = ...): ...
def make_variable(name: Any, shape: Optional[Any] = ..., dtype: Any = ..., initializer: Optional[Any] = ..., trainable: Optional[Any] = ..., caching_device: Optional[Any] = ..., validate_shape: bool = ..., constraint: Optional[Any] = ..., use_resource: Optional[Any] = ..., collections: Optional[Any] = ..., synchronization: Any = ..., aggregation: Any = ..., partitioner: Optional[Any] = ...): ...
def collect_previous_mask(input_tensors: Any): ...
def have_all_keras_metadata(tensors: Any): ...
def generate_placeholders_from_shape(shape: Any): ...
def create_keras_history(tensors: Any): ...
def unnest_if_single_tensor(input_tensors: Any): ...
def needs_keras_history(tensors: Any, ignore_call_context: bool = ...): ...
def is_in_keras_graph(): ...
def is_in_eager_or_tf_function(): ...
def is_in_tf_function(): ...
def uses_keras_history(tensors: Any): ...
def mark_checked(tensors: Any) -> None: ...
def call_context(): ...

class CallContext:
    layer: Any = ...
    inputs: Any = ...
    frozen: bool = ...
    in_call: bool = ...
    training: Any = ...
    saving: bool = ...
    def __init__(self) -> None: ...
    def enter(self, layer: Any, inputs: Any, build_graph: Any, training: Any, saving: Optional[Any] = ...) -> None: ...
    @property
    def in_keras_graph(self): ...

def training_arg_passed_to_call(argspec: Any, args: Any, kwargs: Any): ...
def autocast_context_manager(dtype: Any): ...
def is_subclassed(layer: Any): ...
def from_saved_model(layer: Any): ...
def check_graph_consistency(tensor: Optional[Any] = ..., method: str = ..., force_raise: bool = ...) -> None: ...
def mark_as_return(outputs: Any, acd: Any): ...

V2_DTYPE_BEHAVIOR: Any

def enable_v2_dtype_behavior() -> None: ...
def disable_v2_dtype_behavior() -> None: ...
def v2_dtype_behavior_enabled(): ...

class TrackableWeightHandler:
    def __init__(self, trackable: Any): ...
    @property
    def num_tensors(self): ...
    def set_weights(self, weights: Any) -> None: ...
    def get_tensors(self): ...

REVIVED_LOSS_PLACEHOLDER: str

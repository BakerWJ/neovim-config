from tensorflow.python.eager import context as context
from tensorflow.python.framework import composite_tensor as composite_tensor, constant_op as constant_op, errors as errors, errors_impl as errors_impl, func_graph as func_graph, ops as ops, tensor_shape as tensor_shape
from tensorflow.python.keras import backend as backend
from tensorflow.python.keras.engine import base_layer as base_layer, base_layer_utils as base_layer_utils, compile_utils as compile_utils, training_utils as training_utils
from tensorflow.python.keras.saving import hdf5_format as hdf5_format, save as save
from tensorflow.python.keras.saving.saved_model import network_serialization as network_serialization
from tensorflow.python.keras.utils import generic_utils as generic_utils, layer_utils as layer_utils, tf_utils as tf_utils
from tensorflow.python.keras.utils.io_utils import ask_to_proceed_with_overwrite as ask_to_proceed_with_overwrite
from tensorflow.python.ops import array_ops as array_ops, math_ops as math_ops
from tensorflow.python.ops.ragged import ragged_tensor as ragged_tensor
from tensorflow.python.training import checkpoint_management as checkpoint_management, py_checkpoint_reader as py_checkpoint_reader
from tensorflow.python.training.tracking import data_structures as data_structures, tracking as tracking
from tensorflow.python.util import nest as nest, serialization as serialization, tf_inspect as tf_inspect
from typing import Any, Optional

class Network(base_layer.Layer):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @property
    def dynamic(self): ...
    def __setattr__(self, name: Any, value: Any) -> None: ...
    @property
    def stateful(self): ...
    def reset_states(self) -> None: ...
    @property
    def state_updates(self): ...
    @property
    def weights(self): ...
    def compute_mask(self, inputs: Any, mask: Any): ...
    @property
    def layers(self): ...
    def get_layer(self, name: Optional[Any] = ..., index: Optional[Any] = ...): ...
    @property
    def trainable_weights(self): ...
    @property
    def non_trainable_weights(self): ...
    @property
    def input_spec(self) -> None: ...
    def build(self, input_shape: Any) -> None: ...
    def call(self, inputs: Any, training: Optional[Any] = ..., mask: Optional[Any] = ...): ...
    def compute_output_shape(self, input_shape: Any): ...
    def get_config(self): ...
    @classmethod
    def from_config(cls, config: Any, custom_objects: Optional[Any] = ...): ...
    def save(self, filepath: Any, overwrite: bool = ..., include_optimizer: bool = ..., save_format: Optional[Any] = ..., signatures: Optional[Any] = ..., options: Optional[Any] = ...) -> None: ...
    def save_weights(self, filepath: Any, overwrite: bool = ..., save_format: Optional[Any] = ...) -> None: ...
    def load_weights(self, filepath: Any, by_name: bool = ..., skip_mismatch: bool = ...): ...
    def to_json(self, **kwargs: Any): ...
    def to_yaml(self, **kwargs: Any): ...
    def summary(self, line_length: Optional[Any] = ..., positions: Optional[Any] = ..., print_fn: Optional[Any] = ...) -> None: ...

def connect_ancillary_layers(model: Any, created_layers: Any): ...
def reconstruct_from_config(config: Any, custom_objects: Optional[Any] = ..., created_layers: Optional[Any] = ...): ...
def get_network_config(network: Any, serialize_layer_fn: Optional[Any] = ...): ...

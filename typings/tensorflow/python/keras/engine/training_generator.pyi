from tensorflow.python.data.ops import dataset_ops as dataset_ops, iterator_ops as iterator_ops
from tensorflow.python.eager import context as context
from tensorflow.python.framework import errors as errors
from tensorflow.python.keras import backend as backend
from tensorflow.python.keras.engine import training_utils as training_utils
from tensorflow.python.keras.utils import data_utils as data_utils, generic_utils as generic_utils
from tensorflow.python.keras.utils.mode_keys import ModeKeys as ModeKeys
from tensorflow.python.util import nest as nest
from typing import Any, Optional

def model_iteration(model: Any, data: Any, steps_per_epoch: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_data: Optional[Any] = ..., validation_steps: Optional[Any] = ..., validation_freq: int = ..., class_weight: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ..., shuffle: bool = ..., initial_epoch: int = ..., mode: Any = ..., batch_size: Optional[Any] = ..., steps_name: str = ..., **kwargs: Any): ...

fit_generator: Any
evaluate_generator: Any
predict_generator: Any

def convert_to_generator_like(data: Any, batch_size: Optional[Any] = ..., steps_per_epoch: Optional[Any] = ..., epochs: int = ..., shuffle: bool = ...): ...

class GeneratorOrSequenceTrainingLoop(training_utils.TrainingLoop):
    def fit(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_split: float = ..., validation_data: Optional[Any] = ..., shuffle: bool = ..., class_weight: Optional[Any] = ..., sample_weight: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., validation_steps: Optional[Any] = ..., validation_freq: int = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ...): ...
    def evaluate(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., verbose: int = ..., sample_weight: Optional[Any] = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ...): ...
    def predict(self, model: Any, x: Any, batch_size: Optional[Any] = ..., verbose: int = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., max_queue_size: int = ..., workers: int = ..., use_multiprocessing: bool = ...): ...

class EagerDatasetOrIteratorTrainingLoop(training_utils.TrainingLoop):
    def fit(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_split: float = ..., validation_data: Optional[Any] = ..., shuffle: bool = ..., class_weight: Optional[Any] = ..., sample_weight: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., validation_steps: Optional[Any] = ..., validation_freq: int = ..., **kwargs: Any): ...
    def evaluate(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., verbose: int = ..., sample_weight: Optional[Any] = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., **kwargs: Any): ...
    def predict(self, model: Any, x: Any, batch_size: Optional[Any] = ..., verbose: int = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., **kwargs: Any): ...

class GeneratorLikeTrainingLoop(training_utils.TrainingLoop):
    def fit(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., epochs: int = ..., verbose: int = ..., callbacks: Optional[Any] = ..., validation_split: float = ..., validation_data: Optional[Any] = ..., shuffle: bool = ..., class_weight: Optional[Any] = ..., sample_weight: Optional[Any] = ..., initial_epoch: int = ..., steps_per_epoch: Optional[Any] = ..., validation_steps: Optional[Any] = ..., validation_freq: int = ..., **kwargs: Any): ...
    def evaluate(self, model: Any, x: Optional[Any] = ..., y: Optional[Any] = ..., batch_size: Optional[Any] = ..., verbose: int = ..., sample_weight: Optional[Any] = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., **kwargs: Any): ...
    def predict(self, model: Any, x: Any, batch_size: Optional[Any] = ..., verbose: int = ..., steps: Optional[Any] = ..., callbacks: Optional[Any] = ..., **kwargs: Any): ...

from tensorflow.python.data.experimental.ops import cardinality as cardinality
from tensorflow.python.eager import context as context
from tensorflow.python.framework import composite_tensor as composite_tensor, ops as ops, tensor_shape as tensor_shape, tensor_spec as tensor_spec, tensor_util as tensor_util, type_spec as type_spec
from tensorflow.python.ops import control_flow_ops as control_flow_ops, math_ops as math_ops, variables as variables
from tensorflow.python.util import nest as nest, object_identity as object_identity, tf_contextlib as tf_contextlib
from typing import Any, Optional

def smart_cond(pred: Any, true_fn: Optional[Any] = ..., false_fn: Optional[Any] = ..., name: Optional[Any] = ...): ...
def constant_value(pred: Any): ...
def is_tensor_or_tensor_list(v: Any): ...
def get_reachable_from_inputs(inputs: Any, targets: Optional[Any] = ...): ...
def map_structure_with_atomic(is_atomic_fn: Any, map_fn: Any, nested: Any): ...
def convert_shapes(input_shape: Any, to_tuples: bool = ...): ...

class ListWrapper:
    def __init__(self, list_to_wrap: Any) -> None: ...
    def as_list(self): ...

def convert_inner_node_data(nested: Any, wrap: bool = ...): ...
def shape_type_conversion(fn: Any): ...
def are_all_symbolic_tensors(tensors: Any): ...
def is_symbolic_tensor(tensor: Any): ...
def register_symbolic_tensor_type(cls) -> None: ...
def type_spec_from_value(value: Any): ...
def is_tensor_or_variable(x: Any): ...
def assert_no_legacy_layers(layers: Any) -> None: ...
def maybe_init_scope(layer: Any) -> None: ...
def graph_context_for_symbolic_tensors(*args: Any, **kwargs: Any) -> None: ...
def dataset_is_infinite(dataset: Any): ...
def get_tensor_spec(t: Any, dynamic_batch: bool = ..., name: Optional[Any] = ...): ...
def to_numpy_or_python_type(tensors: Any): ...

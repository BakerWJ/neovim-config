from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2
from tensorflow.python.eager import context as context, execute as execute, tape as tape
from tensorflow.python.eager.graph_only_ops import graph_placeholder as graph_placeholder
from tensorflow.python.framework import auto_control_deps as auto_control_deps, composite_tensor as composite_tensor, constant_op as constant_op, dtypes as dtypes, errors as errors, ops as ops, tensor_spec as tensor_spec, type_spec as type_spec
from tensorflow.python.ops import array_ops as array_ops, custom_gradient as custom_gradient, resource_variable_ops as resource_variable_ops, tensor_array_ops as tensor_array_ops, variable_scope as variable_scope
from tensorflow.python.util import compat as compat, memory as memory, nest as nest, object_identity as object_identity, tf_contextlib as tf_contextlib, tf_decorator as tf_decorator
from typing import Any, Optional

WHITELIST_COLLECTIONS: Any

class UnknownArgument: ...

def convert_structure_to_signature(structure: Any, arg_names: Optional[Any] = ...): ...

class FuncGraph(ops.Graph):
    name: Any = ...
    inputs: Any = ...
    outputs: Any = ...
    control_outputs: Any = ...
    control_captures: Any = ...
    structured_input_signature: Any = ...
    structured_outputs: Any = ...
    capture_by_value: Any = ...
    seed: Any = ...
    def __init__(self, name: Any, collections: Optional[Any] = ..., capture_by_value: Optional[Any] = ...) -> None: ...
    def watch_variable(self, v: Any) -> None: ...
    def capture_call_time_value(self, closure: Any, spec: Any, key: Optional[Any] = ...): ...
    def control_dependencies(self, control_inputs: Any): ...
    def as_default(self): ...
    @property
    def outer_graph(self): ...
    @property
    def output_types(self): ...
    @property
    def output_shapes(self): ...
    @property
    def trainable_variables(self): ...
    @property
    def variables(self): ...
    @variables.setter
    def variables(self, var_list: Any) -> None: ...
    def capture(self, tensor: Any, name: Optional[Any] = ..., shape: Optional[Any] = ...): ...
    @property
    def captures(self): ...
    def add_capture(self, tensor: Any, placeholder: Any) -> None: ...
    def replace_capture(self, tensor: Any, placeholder: Any) -> None: ...
    def reset_captures(self, capture_list: Any) -> None: ...
    def pop_capture(self, tensor: Any): ...
    def clear_captures(self) -> None: ...
    def capture_distributed_variable(self, variable: Any, placeholder: Any): ...
    def capture_eager_tensor(self, tensor: Any, name: Any): ...
    def captured(self, tensor: Any): ...
    @property
    def external_captures(self): ...
    @property
    def internal_captures(self): ...
    @property
    def deferred_external_captures(self): ...
    @property
    def deferred_internal_captures(self): ...
    @property
    def variable_captures(self): ...
    def mark_as_unsaveable(self, error_message: Any) -> None: ...
    @property
    def saveable(self): ...
    @property
    def saving_errors(self): ...

def func_graph_from_py_func(name: Any, python_func: Any, args: Any, kwargs: Any, signature: Optional[Any] = ..., func_graph: Optional[Any] = ..., autograph: bool = ..., autograph_options: Optional[Any] = ..., add_control_dependencies: bool = ..., arg_names: Optional[Any] = ..., op_return_value: Optional[Any] = ..., collections: Optional[Any] = ..., capture_by_value: Optional[Any] = ..., override_flat_arg_shapes: Optional[Any] = ...): ...
def maybe_captured(tensor: Any): ...
def device_stack_has_callable(device_stack: Any): ...
def check_mutation(n1: Any, n2: Any, func: Any) -> None: ...
def flatten(sequence: Any): ...
def pack_sequence_as(structure: Any, flat_sequence: Any): ...
def dismantle_func_graph(func_graph: Any) -> None: ...

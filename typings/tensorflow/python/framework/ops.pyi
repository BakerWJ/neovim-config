import threading
from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2, function_pb2 as function_pb2, graph_pb2 as graph_pb2, node_def_pb2 as node_def_pb2, op_def_pb2 as op_def_pb2, versions_pb2 as versions_pb2
from tensorflow.core.protobuf import config_pb2 as config_pb2
from tensorflow.python import pywrap_tensorflow as pywrap_tensorflow, pywrap_tfe as pywrap_tfe, tf2 as tf2
from tensorflow.python.client import pywrap_tf_session as pywrap_tf_session
from tensorflow.python.eager import context as context, core as core, monitoring as monitoring, tape as tape
from tensorflow.python.framework import c_api_util as c_api_util, composite_tensor as composite_tensor, dtypes as dtypes, errors as errors, indexed_slices as indexed_slices, registry as registry, tensor_conversion_registry as tensor_conversion_registry, tensor_like as tensor_like, tensor_shape as tensor_shape, traceable_stack as traceable_stack, versions as versions
from tensorflow.python.ops import control_flow_util as control_flow_util
from tensorflow.python.platform import app as app
from tensorflow.python.util import compat as compat, decorator_utils as decorator_utils, deprecation as deprecation, function_utils as function_utils, lock_util as lock_util, memory as memory, object_identity as object_identity, tf_contextlib as tf_contextlib, tf_stack as tf_stack
from tensorflow.python.util.compat import collections_abc as collections_abc
from tensorflow.python.util.deprecation import deprecated_args as deprecated_args
from tensorflow.python.util.lazy_loader import LazyLoader as LazyLoader
from tensorflow.python.util.tf_export import kwarg_only as kwarg_only, tf_export as tf_export
from typing import Any, Optional

ag_ctx: Any

def tensor_id(tensor: Any): ...

class _UserDeviceSpec:
    display_name: Any = ...
    function: Any = ...
    raw_string: Any = ...
    is_null_merge: Any = ...
    fast_string_merge: Any = ...
    def __init__(self, device_name_or_function: Any) -> None: ...
    def string_merge(self, node_def: Any): ...

class NullContextmanager:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type_arg: Any, value_arg: Any, traceback_arg: Any): ...

def is_dense_tensor_like(t: Any): ...
def register_dense_tensor_like_type(tensor_type: Any) -> None: ...
def uid(): ...
def numpy_text(tensor: Any, is_repr: bool = ...): ...
def enable_tensor_equality() -> None: ...
def disable_tensor_equality() -> None: ...

class Tensor(_TensorLike):
    OVERLOADABLE_OPERATORS: Any = ...
    def __init__(self, op: Any, value_index: Any, dtype: Any) -> None: ...
    @property
    def op(self): ...
    @property
    def dtype(self): ...
    @property
    def graph(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    @property
    def shape(self): ...
    def __iter__(self) -> Any: ...
    def get_shape(self): ...
    def set_shape(self, shape: Any) -> None: ...
    @property
    def value_index(self): ...
    def consumers(self): ...
    def __hash__(self) -> Any: ...
    def __copy__(self): ...
    __array_priority__: int = ...
    def __array__(self) -> None: ...
    def __len__(self) -> None: ...
    def __bool__(self) -> None: ...
    def __nonzero__(self) -> None: ...
    def eval(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...): ...
    def experimental_ref(self): ...
    def ref(self): ...

class _EagerTensorBase(Tensor):
    def __complex__(self): ...
    def __int__(self): ...
    def __long__(self): ...
    def __float__(self): ...
    def __index__(self): ...
    def __bool__(self): ...
    __nonzero__: Any = ...
    def __format__(self, format_spec: Any): ...
    def __reduce__(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def __len__(self): ...
    @property
    def dtype(self): ...
    def numpy(self): ...
    @property
    def backing_device(self) -> None: ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    @property
    def ndim(self): ...
    def cpu(self): ...
    def gpu(self, gpu_index: int = ...): ...
    def set_shape(self, shape: Any) -> None: ...
    @property
    def op(self) -> None: ...
    @property
    def graph(self) -> None: ...
    @property
    def name(self) -> None: ...
    @property
    def value_index(self) -> None: ...
    def consumers(self) -> None: ...
    def eval(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...) -> None: ...

EagerTensor: Any

def convert_to_tensor_v1(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., preferred_dtype: Optional[Any] = ..., dtype_hint: Optional[Any] = ...): ...
def convert_to_tensor_v2(value: Any, dtype: Optional[Any] = ..., dtype_hint: Optional[Any] = ..., name: Optional[Any] = ...): ...
def convert_to_tensor(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ..., preferred_dtype: Optional[Any] = ..., dtype_hint: Optional[Any] = ..., ctx: Optional[Any] = ..., accepted_result_types: Any = ...): ...
internal_convert_to_tensor = convert_to_tensor

def internal_convert_n_to_tensor(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ..., preferred_dtype: Optional[Any] = ..., ctx: Optional[Any] = ...): ...
def convert_n_to_tensor(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., preferred_dtype: Optional[Any] = ...): ...
def convert_to_tensor_or_composite(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def internal_convert_to_tensor_or_composite(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ...): ...
def internal_convert_n_to_tensor_or_composite(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ..., as_ref: bool = ...): ...
def convert_n_to_tensor_or_composite(values: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...

class Operation:
    def __init__(self, node_def: Any, g: Any, inputs: Optional[Any] = ..., output_types: Optional[Any] = ..., control_inputs: Optional[Any] = ..., input_types: Optional[Any] = ..., original_op: Optional[Any] = ..., op_def: Optional[Any] = ...) -> None: ...
    def colocation_groups(self): ...
    def values(self): ...
    @property
    def name(self): ...
    @property
    def device(self): ...
    @property
    def outputs(self): ...
    @property
    def inputs(self): ...
    @property
    def control_inputs(self): ...
    @property
    def type(self): ...
    @property
    def graph(self): ...
    @property
    def node_def(self): ...
    @property
    def op_def(self): ...
    @property
    def traceback(self): ...
    def get_attr(self, name: Any): ...
    def run(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...) -> None: ...

class RegisterGradient:
    def __init__(self, op_type: Any) -> None: ...
    def __call__(self, f: Any): ...

def no_gradient(op_type: Any) -> None: ...
NoGradient = no_gradient
NotDifferentiable = no_gradient

def get_gradient_function(op: Any): ...
def set_shape_and_handle_data_for_outputs(_: Any) -> None: ...

class OpStats:
    def __init__(self, statistic_type: Any, value: Optional[Any] = ...) -> None: ...
    @property
    def statistic_type(self): ...
    @statistic_type.setter
    def statistic_type(self, statistic_type: Any) -> None: ...
    @property
    def value(self): ...
    @value.setter
    def value(self, value: Any) -> None: ...
    def __iadd__(self, other: Any): ...

class RegisterStatistics:
    def __init__(self, op_type: Any, statistic_type: Any) -> None: ...
    def __call__(self, f: Any): ...

def get_stats_for_node_def(graph: Any, node: Any, statistic_type: Any): ...
def name_from_scope_name(name: Any): ...

class Graph:
    def __init__(self) -> None: ...
    @property
    def version(self): ...
    @property
    def graph_def_versions(self): ...
    @property
    def seed(self): ...
    @seed.setter
    def seed(self, seed: Any) -> None: ...
    @property
    def finalized(self): ...
    def finalize(self) -> None: ...
    def as_graph_def(self, from_version: Optional[Any] = ..., add_shapes: bool = ...): ...
    @property
    def building_function(self): ...
    def create_op(self, op_type: Any, inputs: Any, dtypes: Optional[Any] = ..., input_types: Optional[Any] = ..., name: Optional[Any] = ..., attrs: Optional[Any] = ..., op_def: Optional[Any] = ..., compute_shapes: bool = ..., compute_device: bool = ...): ...
    def as_graph_element(self, obj: Any, allow_tensor: bool = ..., allow_operation: bool = ...): ...
    def get_operations(self): ...
    def get_operation_by_name(self, name: Any): ...
    def get_tensor_by_name(self, name: Any): ...
    def as_default(self): ...
    @property
    def collections(self): ...
    def add_to_collection(self, name: Any, value: Any) -> None: ...
    def add_to_collections(self, names: Any, value: Any) -> None: ...
    def get_collection_ref(self, name: Any): ...
    def get_collection(self, name: Any, scope: Optional[Any] = ...): ...
    def get_all_collection_keys(self): ...
    def clear_collection(self, name: Any) -> None: ...
    def name_scope(self, name: Any) -> None: ...
    def unique_name(self, name: Any, mark_as_used: bool = ...): ...
    def get_name_scope(self): ...
    def colocate_with(self, op: Any, ignore_existing: bool = ...) -> None: ...
    def device(self, device_name_or_function: Any) -> None: ...
    def container(self, container_name: Any) -> None: ...
    class _ControlDependenciesController:
        def __init__(self, graph: Any, control_inputs: Any) -> None: ...
        def __enter__(self) -> None: ...
        def __exit__(self, unused_type: Any, unused_value: Any, unused_traceback: Any) -> None: ...
        @property
        def control_inputs(self): ...
        def add_op(self, op: Any) -> None: ...
        def op_in_group(self, op: Any): ...
    def control_dependencies(self, control_inputs: Any): ...
    def gradient_override_map(self, op_type_map: Any) -> None: ...
    def prevent_feeding(self, tensor: Any) -> None: ...
    def is_feedable(self, tensor: Any): ...
    def prevent_fetching(self, op: Any) -> None: ...
    def is_fetchable(self, tensor_or_op: Any): ...
    def switch_to_thread_local(self) -> None: ...

def device(device_name_or_function: Any): ...
def device_v2(device_name: Any): ...
def container(container_name: Any): ...
def colocate_with(op: Any, ignore_existing: bool = ...): ...
def control_dependencies(control_inputs: Any): ...

class _DefaultStack(threading.local):
    stack: Any = ...
    def __init__(self) -> None: ...
    def get_default(self): ...
    def reset(self) -> None: ...
    def is_cleared(self): ...
    @property
    def enforce_nesting(self): ...
    @enforce_nesting.setter
    def enforce_nesting(self, value: Any) -> None: ...
    def get_controller(self, default: Any) -> None: ...

def default_session(session: Any): ...
def get_default_session(): ...

class _DefaultGraphStack(_DefaultStack):
    def __init__(self) -> None: ...
    def get_default(self): ...
    def reset(self) -> None: ...
    def get_controller(self, default: Any) -> None: ...

def init_scope() -> None: ...
def executing_eagerly_outside_functions(): ...
def inside_function(): ...
def enable_eager_execution(config: Optional[Any] = ..., device_policy: Optional[Any] = ..., execution_mode: Optional[Any] = ...): ...
def disable_eager_execution() -> None: ...
def enable_eager_execution_internal(config: Optional[Any] = ..., device_policy: Optional[Any] = ..., execution_mode: Optional[Any] = ..., server_def: Optional[Any] = ...) -> None: ...
def eager_run(main: Optional[Any] = ..., argv: Optional[Any] = ...) -> None: ...
def reset_default_graph() -> None: ...
def get_default_graph(): ...
def has_default_graph(): ...
def get_name_scope(): ...

class GraphKeys:
    GLOBAL_VARIABLES: str = ...
    LOCAL_VARIABLES: str = ...
    METRIC_VARIABLES: str = ...
    MODEL_VARIABLES: str = ...
    TRAINABLE_VARIABLES: str = ...
    SUMMARIES: str = ...
    QUEUE_RUNNERS: str = ...
    TABLE_INITIALIZERS: str = ...
    ASSET_FILEPATHS: str = ...
    MOVING_AVERAGE_VARIABLES: str = ...
    REGULARIZATION_LOSSES: str = ...
    CONCATENATED_VARIABLES: str = ...
    SAVERS: str = ...
    WEIGHTS: str = ...
    BIASES: str = ...
    ACTIVATIONS: str = ...
    UPDATE_OPS: str = ...
    LOSSES: str = ...
    SAVEABLE_OBJECTS: str = ...
    RESOURCES: str = ...
    LOCAL_RESOURCES: str = ...
    TRAINABLE_RESOURCE_VARIABLES: str = ...
    INIT_OP: str = ...
    LOCAL_INIT_OP: str = ...
    READY_OP: str = ...
    READY_FOR_LOCAL_INIT_OP: str = ...
    SUMMARY_OP: str = ...
    GLOBAL_STEP: str = ...
    EVAL_STEP: str = ...
    TRAIN_OP: str = ...
    COND_CONTEXT: str = ...
    WHILE_CONTEXT: str = ...
    def VARIABLES(cls): ...

def dismantle_graph(graph: Any) -> None: ...
def add_to_collection(name: Any, value: Any) -> None: ...
def add_to_collections(names: Any, value: Any) -> None: ...
def get_collection_ref(key: Any): ...
def get_collection(key: Any, scope: Optional[Any] = ...): ...
def get_all_collection_keys(): ...
def name_scope(name: Any, default_name: Optional[Any] = ..., values: Optional[Any] = ..., skip_on_eager: bool = ...): ...

class internal_name_scope_v1:
    @property
    def name(self): ...
    def __init__(self, name: Any, default_name: Optional[Any] = ..., values: Optional[Any] = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *exc_info: Any) -> None: ...

class name_scope_v1:
    @property
    def name(self): ...
    def __init__(self, name: Any, default_name: Optional[Any] = ..., values: Optional[Any] = ...) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *exc_info: Any): ...

def enter_eager_name_scope(ctx: Any, name: Any): ...

class name_scope_v2:
    def __init__(self, name: Any) -> None: ...
    @property
    def name(self): ...
    def __enter__(self): ...
    def __exit__(self, type_arg: Any, value_arg: Any, traceback_arg: Any): ...

def strip_name_scope(name: Any, export_scope: Any): ...
def prepend_name_scope(name: Any, import_scope: Any): ...
def op_scope(values: Any, name: Any, default_name: Optional[Any] = ...) -> None: ...
def register_proto_function(collection_name: Any, proto_type: Optional[Any] = ..., to_proto: Optional[Any] = ..., from_proto: Optional[Any] = ...) -> None: ...
def get_collection_proto_type(collection_name: Any): ...
def get_to_proto_function(collection_name: Any): ...
def get_from_proto_function(collection_name: Any): ...

IndexedSlices: Any
IndexedSlicesValue: Any
convert_to_tensor_or_indexed_slices: Any
convert_n_to_tensor_or_indexed_slices: Any
internal_convert_to_tensor_or_indexed_slices: Any
internal_convert_n_to_tensor_or_indexed_slices: Any
register_tensor_conversion_function = tensor_conversion_registry.register_tensor_conversion_function

def to_raw_op(f: Any): ...
def raise_from_not_ok_status(e: Any, name: Any) -> None: ...
def add_exit_callback_to_default_func_graph(fn: Any) -> None: ...

class _TensorIterator:
    def __init__(self, tensor: Any, dim0: Any) -> None: ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    next: Any = ...

def set_int_list_attr(op: Any, attr_name: Any, ints: Any) -> None: ...

from collections import namedtuple
from tensorflow.python import pywrap_tensorflow as pywrap_tensorflow, tf2 as tf2
from tensorflow.python.framework import composite_tensor as composite_tensor, constant_op as constant_op, dtypes as dtypes, ops as ops, tensor_like as tensor_like, tensor_shape as tensor_shape, tensor_spec as tensor_spec, tensor_util as tensor_util, type_spec as type_spec
from tensorflow.python.ops import gen_sparse_ops as gen_sparse_ops
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

class SparseTensor(_TensorLike, composite_tensor.CompositeTensor):
    @classmethod
    def from_value(cls, sparse_tensor_value: Any): ...
    def __init__(self, indices: Any, values: Any, dense_shape: Any) -> None: ...
    def get_shape(self): ...
    @property
    def indices(self): ...
    @property
    def values(self): ...
    @property
    def op(self): ...
    @property
    def dtype(self): ...
    @property
    def dense_shape(self): ...
    @property
    def shape(self): ...
    @property
    def graph(self): ...
    def eval(self, feed_dict: Optional[Any] = ..., session: Optional[Any] = ...): ...
    def consumers(self): ...

SparseTensorValue = namedtuple('SparseTensorValue', ['indices', 'values', 'dense_shape'])

class SparseTensorSpec(type_spec.BatchableTypeSpec):
    value_type: Any = ...
    def __init__(self, shape: Optional[Any] = ..., dtype: Any = ...) -> None: ...
    @property
    def dtype(self): ...
    @property
    def shape(self): ...
    @classmethod
    def from_value(cls, value: Any): ...

def convert_to_tensor_or_sparse_tensor(value: Any, dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...
def is_sparse(x: Any): ...

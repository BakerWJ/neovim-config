from .....third_party import wrapt
from tensorflow.python.eager import def_function as def_function
from tensorflow.python.ops import variables as variables
from tensorflow.python.saved_model import revived_types as revived_types
from tensorflow.python.training.tracking import base as base, layer_utils as layer_utils
from tensorflow.python.util.compat import collections_abc as collections_abc
from typing import Any, Optional

class NoDependency:
    value: Any = ...
    def __init__(self, value: Any) -> None: ...

def wrap_or_unwrap(value: Any): ...
def sticky_attribute_assignment(trackable: Any, name: Any, value: Any): ...

class _UntrackableError(ValueError):
    def __init__(self, value: Any) -> None: ...

class TrackableDataStructure(base.Trackable):
    def __init__(self) -> None: ...
    @property
    def trainable(self): ...
    @trainable.setter
    def trainable(self, value: Any) -> None: ...
    @property
    def layers(self): ...
    @property
    def trainable_weights(self): ...
    @property
    def non_trainable_weights(self): ...
    @property
    def weights(self): ...
    @property
    def trainable_variables(self): ...
    @property
    def non_trainable_variables(self): ...
    @property
    def variables(self): ...
    @property
    def updates(self): ...
    @property
    def losses(self): ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...

class List(TrackableDataStructure, collections_abc.Sequence):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def copy(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def append(self, value: Any) -> None: ...
    def extend(self, values: Any) -> None: ...
    def __iadd__(self, values: Any): ...
    def __add__(self, other: Any): ...
    def __imul__(self, y: Any): ...
    def __mul__(self, n: Any): ...
    def __rmul__(self, n: Any): ...
    def __radd__(self, other: Any): ...
    def __getitem__(self, key: Any): ...
    def __getslice__(self, i: Any, j: Any): ...
    def __len__(self): ...
    def __sizeof__(self): ...

class ListWrapper(List, collections_abc.MutableSequence, list):
    def __init__(self, wrapped_list: Any) -> None: ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def __reduce_ex__(self, protocol: Any): ...
    def __delitem__(self, key: Any) -> None: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def append(self, value: Any) -> None: ...
    def extend(self, values: Any) -> None: ...
    def __imul__(self, y: Any): ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __lt__(self, other: Any) -> Any: ...
    def __le__(self, other: Any) -> Any: ...
    def __gt__(self, other: Any) -> Any: ...
    def __ge__(self, other: Any) -> Any: ...
    def __hash__(self) -> Any: ...
    def insert(self, index: Any, obj: Any) -> None: ...
    def sort(self) -> None: ...
    def __setslice__(self, i: Any, j: Any, y: Any) -> None: ...
    def __delslice__(self, i: Any, j: Any) -> None: ...

class Mapping(TrackableDataStructure, collections_abc.Mapping):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...
    def __getitem__(self, key: Any): ...
    def __len__(self): ...
    def __iter__(self) -> Any: ...

class _DictWrapper(TrackableDataStructure, wrapt.ObjectProxy):
    def __init__(self, wrapped_dict: Optional[Any] = ...) -> None: ...
    def __reduce_ex__(self, protocol: Any): ...
    def __getattribute__(self, name: Any): ...
    def copy(self): ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def update(self, *args: Any, **kwargs: Any) -> None: ...

class _TupleWrapper(TrackableDataStructure, wrapt.ObjectProxy):
    def __init__(self, original_wrapped_tuple: Any = ...) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: Any): ...
    def __reduce_ex__(self, protocol: Any): ...
    def __imul__(self, y: Any): ...
    def __iadd__(self, y: Any): ...
    def __getattribute__(self, name: Any): ...

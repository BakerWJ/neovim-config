from tensorflow.python.distribute import device_util as device_util, distribute_lib as distribute_lib, input_lib as input_lib, numpy_dataset as numpy_dataset, values as values
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, ops as ops
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops
from tensorflow.python.util import nest as nest
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

class OneDeviceStrategy(distribute_lib.Strategy):
    def __init__(self, device: Any) -> None: ...
    def experimental_distribute_dataset(self, dataset: Any): ...
    def experimental_distribute_datasets_from_function(self, dataset_fn: Any): ...
    def experimental_local_results(self, value: Any): ...
    def run(self, fn: Any, args: Any = ..., kwargs: Optional[Any] = ..., options: Optional[Any] = ...): ...
    def reduce(self, reduce_op: Any, value: Any, axis: Any): ...
    def scope(self): ...

class OneDeviceStrategyV1(distribute_lib.StrategyV1):
    __doc__: Any = ...
    def __init__(self, device: Any) -> None: ...

class OneDeviceExtended(distribute_lib.StrategyExtendedV1):
    def __init__(self, container_strategy: Any, device: Any) -> None: ...
    def read_var(self, replica_local_var: Any): ...
    def value_container(self, value: Any): ...
    @property
    def worker_devices(self): ...
    @property
    def parameter_devices(self): ...
    def non_slot_devices(self, var_list: Any): ...
    @property
    def experimental_should_init(self): ...
    @property
    def experimental_between_graph(self): ...
    @property
    def should_checkpoint(self): ...
    @property
    def should_save_summary(self): ...

class _OneDeviceReplicaContext(distribute_lib.ReplicaContext):
    def __init__(self, strategy: Any) -> None: ...
    @property
    def devices(self): ...

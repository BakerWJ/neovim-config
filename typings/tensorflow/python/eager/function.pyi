from collections import namedtuple
from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2, function_pb2 as function_pb2
from tensorflow.python import pywrap_tfe as pywrap_tfe
from tensorflow.python.client import pywrap_tf_session as pywrap_tf_session
from tensorflow.python.eager import backprop as backprop, backprop_util as backprop_util, context as context, execute as execute, forwardprop_util as forwardprop_util, tape as tape
from tensorflow.python.eager.graph_only_ops import graph_placeholder as graph_placeholder
from tensorflow.python.framework import c_api_util as c_api_util, composite_tensor as composite_tensor, constant_op as constant_op, dtypes as dtypes, error_interpolation as error_interpolation, errors as errors, ops as ops, tensor_shape as tensor_shape, tensor_spec as tensor_spec
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, custom_gradient as custom_gradient, default_gradient as default_gradient, functional_ops as functional_ops, gradients_util as gradients_util, resource_variable_ops as resource_variable_ops
from tensorflow.python.util import compat as compat, function_utils as function_utils, lazy_loader as lazy_loader, memory as memory, nest as nest, object_identity as object_identity, tf_decorator as tf_decorator, tf_inspect as tf_inspect
from typing import Any, Optional

ag_ctx: Any
FORWARD_FUNCTION_ATTRIBUTE_NAME: str
BACKWARD_FUNCTION_ATTRIBUTE_NAME: str
IMPLEMENTS_ATTRIBUTE_NAME: str

CacheKey = namedtuple('CacheKey', ['input_signature', 'parent_graph', 'device_functions', 'colocation_stack', 'in_cross_replica_context', 'xla_context_id'])

def common_shape(x: Any, y: Any): ...
def is_same_structure(structure1: Any, structure2: Any, check_values: bool = ...): ...

class _InterpolateFunctionError:
    def __init__(self, top_level_func: Any) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, typ: Any, exc: Any, tb: Any): ...

def add_function_callback(function_callback: Any) -> None: ...
def remove_function_callback(function_callback: Any) -> None: ...
def clear_function_callbacks() -> None: ...

class _EagerDefinedFunctionDeleter:
    name: Any = ...
    def __init__(self, name: Any) -> None: ...
    def __del__(self) -> None: ...

class _EagerDefinedFunction:
    definition: Any = ...
    signature: Any = ...
    grad_func_name: Any = ...
    python_grad_func: Any = ...
    graph: Any = ...
    def __init__(self, name: Any, graph: Any, inputs: Any, outputs: Any, attrs: Any) -> None: ...
    def add_to_graph(self, g: Optional[Any] = ...) -> None: ...
    @property
    def name(self): ...
    @property
    def stateful_ops(self): ...
    def call(self, ctx: Any, args: Any, cancellation_manager: Optional[Any] = ...): ...

class _DelayedRewriteGradientFunctions:
    def __init__(self, func_graph: Any, attrs: Any, func_graph_deleter: Any) -> None: ...
    def forward_backward(self, num_doutputs: Optional[Any] = ...): ...
    def get_gradient_function(self): ...
    def forward(self, inference_args: Optional[Any] = ..., input_tangents: Optional[Any] = ...): ...
    def record(self, flat_outputs: Any, inference_args: Any, input_tangents: Any) -> None: ...

_ForwardWrapper = namedtuple('_ForwardWrapper', ['graph', 'outputs', 'output_indices', 'output_tangents'])

class _TapeGradientFunctions:
    def __init__(self, func_graph: Any, attrs: Any, func_graph_deleter: Any, forwardprop_input_indices: Any, delayed_rewrite_functions: Any, need_gradients_for_jvps: Any) -> None: ...
    def forward(self, inference_args: Any, input_tangents: Any): ...
    def record(self, flat_outputs: Any, inference_args: Any, input_tangents: Any) -> None: ...

class _FirstOrderTapeGradientFunctions(_TapeGradientFunctions):
    def __init__(self, func_graph: Any, attrs: Any, func_graph_deleter: Any, forwardprop_input_indices: Any, delayed_rewrite_functions: Any, need_gradients_for_jvps: Any) -> None: ...

class _HigherOrderTapeGradientFunctions(_TapeGradientFunctions): ...

class _ForwardBackwardCall:
    def __init__(self, functions: Any, inference_args: Any, input_tangents: Any, tape_watching: Any) -> None: ...
    def forward(self): ...
    def record(self, flat_outputs: Any) -> None: ...

class ConcreteFunction:
    def __init__(self, func_graph: Any, attrs: Optional[Any] = ..., signature: Optional[Any] = ..., shared_func_graph: bool = ...) -> None: ...
    @property
    def variables(self): ...
    @property
    def trainable_variables(self): ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    @property
    def name(self): ...
    @property
    def graph(self): ...
    @property
    def inputs(self): ...
    @property
    def structured_input_signature(self): ...
    @property
    def outputs(self): ...
    @property
    def structured_outputs(self): ...
    @property
    def captured_inputs(self): ...
    @property
    def function_def(self): ...
    @property
    def output_shapes(self): ...
    @property
    def output_dtypes(self): ...
    def add_to_graph(self, g: Optional[Any] = ...) -> None: ...
    def add_gradient_functions_to_graph(self, g: Optional[Any] = ...) -> None: ...

class FunctionSpec:
    @staticmethod
    def from_function_and_signature(python_function: Any, input_signature: Any, is_pure: bool = ...): ...
    arg_names: Any = ...
    vararg_name: Any = ...
    def __init__(self, fullargspec: Any, is_method: Any, args_to_prepend: Any, kwargs_to_include: Any, input_signature: Any, is_pure: bool = ...) -> None: ...
    @property
    def fullargspec(self): ...
    @property
    def is_method(self): ...
    @property
    def args_to_prepend(self): ...
    @property
    def kwargs_to_include(self): ...
    @property
    def input_signature(self): ...
    @property
    def flat_input_signature(self): ...
    def canonicalize_function_inputs(self, *args: Any, **kwargs: Any): ...

class FunctionCache:
    missed: Any = ...
    primary: Any = ...
    arg_relaxed_shapes: Any = ...
    arg_relaxed: Any = ...
    def __init__(self) -> None: ...
    def all_values(self): ...

class Function:
    tracing_count: int = ...
    def __init__(self, python_function: Any, name: Any, input_signature: Optional[Any] = ..., attributes: Optional[Any] = ..., autograph: bool = ..., autograph_options: Optional[Any] = ..., experimental_relax_shapes: bool = ..., capture_by_value: Optional[Any] = ..., experimental_compile: Optional[Any] = ...) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    @property
    def python_function(self): ...
    @property
    def function_spec(self): ...
    @property
    def input_signature(self): ...
    @property
    def flat_input_signature(self): ...
    def get_concrete_function(self, *args: Any, **kwargs: Any): ...
    def __get__(self, instance: Any, owner: Any): ...

def register(func: Any, *args: Any, **kwargs: Any): ...
def validate_signature(signature: Any) -> None: ...
def defun(func: Optional[Any] = ..., input_signature: Optional[Any] = ..., autograph: bool = ..., experimental_autograph_options: Optional[Any] = ..., experimental_relax_shapes: bool = ...): ...
def defun_with_attributes(func: Optional[Any] = ..., input_signature: Optional[Any] = ..., attributes: Optional[Any] = ..., autograph: bool = ..., experimental_autograph_options: Optional[Any] = ..., experimental_compile: Optional[Any] = ..., experimental_relax_shapes: bool = ...): ...

class TfMethodTarget:
    weakrefself_target__: Any = ...
    weakrefself_func__: Any = ...
    def __init__(self, target: Any, original_python_function: Any) -> None: ...
    @property
    def target(self): ...
    @property
    def target_class(self): ...
    def call(self, args: Any, kwargs: Any): ...

def class_method_to_instance_method(original_function: Any, instance: Any): ...

class _FunctionGarbageCollector:
    def __init__(self, cache: Any) -> None: ...
    def __del__(self) -> None: ...

class ConcreteFunctionGarbageCollector:
    def __init__(self, func_graph: Any) -> None: ...
    def release(self) -> None: ...
    def __del__(self) -> None: ...

from collections import namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

def abort(error_msg: str = ..., exit_without_error: bool = ..., name: Optional[Any] = ...): ...

Abort: Any

def abort_eager_fallback(error_msg: Any, exit_without_error: Any, name: Any, ctx: Any): ...
def control_trigger(name: Optional[Any] = ...): ...

ControlTrigger: Any

def control_trigger_eager_fallback(name: Any, ctx: Any): ...
def enter(data: Any, frame_name: Any, is_constant: bool = ..., parallel_iterations: int = ..., name: Optional[Any] = ...): ...

Enter: Any

def enter_eager_fallback(data: Any, frame_name: Any, is_constant: Any, parallel_iterations: Any, name: Any, ctx: Any): ...

Exit: Any

def loop_cond(input: Any, name: Optional[Any] = ...): ...

LoopCond: Any

def loop_cond_eager_fallback(input: Any, name: Any, ctx: Any): ...

_MergeOutput = namedtuple('Merge', ['output', 'value_index'])

def merge(inputs: Any, name: Optional[Any] = ...): ...

Merge: Any

def merge_eager_fallback(inputs: Any, name: Any, ctx: Any): ...
def next_iteration(data: Any, name: Optional[Any] = ...): ...

NextIteration: Any

def next_iteration_eager_fallback(data: Any, name: Any, ctx: Any): ...
def no_op(name: Optional[Any] = ...): ...

NoOp: Any

def no_op_eager_fallback(name: Any, ctx: Any): ...
def ref_enter(data: Any, frame_name: Any, is_constant: bool = ..., parallel_iterations: int = ..., name: Optional[Any] = ...): ...

RefEnter: Any

def ref_enter_eager_fallback(data: Any, frame_name: Any, is_constant: Any, parallel_iterations: Any, name: Any, ctx: Any) -> None: ...
def ref_exit(data: Any, name: Optional[Any] = ...): ...

RefExit: Any

def ref_exit_eager_fallback(data: Any, name: Any, ctx: Any) -> None: ...

_RefMergeOutput = namedtuple('RefMerge', ['output', 'value_index'])

def ref_merge(inputs: Any, name: Optional[Any] = ...): ...

RefMerge: Any

def ref_merge_eager_fallback(inputs: Any, name: Any, ctx: Any) -> None: ...
def ref_next_iteration(data: Any, name: Optional[Any] = ...): ...

RefNextIteration: Any

def ref_next_iteration_eager_fallback(data: Any, name: Any, ctx: Any) -> None: ...
def ref_select(index: Any, inputs: Any, name: Optional[Any] = ...): ...

RefSelect: Any

def ref_select_eager_fallback(index: Any, inputs: Any, name: Any, ctx: Any) -> None: ...

_RefSwitchOutput = namedtuple('RefSwitch', ['output_false', 'output_true'])

def ref_switch(data: Any, pred: Any, name: Optional[Any] = ...): ...

RefSwitch: Any

def ref_switch_eager_fallback(data: Any, pred: Any, name: Any, ctx: Any) -> None: ...

_SwitchOutput = namedtuple('Switch', ['output_false', 'output_true'])

def switch(data: Any, pred: Any, name: Optional[Any] = ...): ...

Switch: Any

def switch_eager_fallback(data: Any, pred: Any, name: Any, ctx: Any): ...

from tensorflow.python.eager import context as context
from tensorflow.python.framework import constant_op as constant_op, device as device, dtypes as dtypes, function as function, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape
from tensorflow.python.ops import array_ops as array_ops, custom_gradient as custom_gradient, functional_ops as functional_ops, gen_ctc_ops as gen_ctc_ops, inplace_ops as inplace_ops, linalg_ops as linalg_ops, map_fn as map_fn, math_ops as math_ops, nn_ops as nn_ops, sparse_ops as sparse_ops
from tensorflow.python.util import deprecation as deprecation, nest as nest
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

def ctc_loss(labels: Any, inputs: Optional[Any] = ..., sequence_length: Optional[Any] = ..., preprocess_collapse_repeated: bool = ..., ctc_merge_repeated: bool = ..., ignore_longer_outputs_than_inputs: bool = ..., time_major: bool = ..., logits: Optional[Any] = ...): ...
def ctc_greedy_decoder(inputs: Any, sequence_length: Any, merge_repeated: bool = ...): ...
def ctc_beam_search_decoder(inputs: Any, sequence_length: Any, beam_width: int = ..., top_paths: int = ..., merge_repeated: bool = ...): ...
def ctc_beam_search_decoder_v2(inputs: Any, sequence_length: Any, beam_width: int = ..., top_paths: int = ...): ...
def ctc_state_log_probs(seq_lengths: Any, max_seq_length: Any): ...
def ctc_loss_and_grad(logits: Any, labels: Any, label_length: Any, logit_length: Any, unique: Optional[Any] = ...): ...
def ctc_loss_v2(labels: Any, logits: Any, label_length: Any, logit_length: Any, logits_time_major: bool = ..., unique: Optional[Any] = ..., blank_index: Optional[Any] = ..., name: Optional[Any] = ...): ...
def ctc_loss_v3(labels: Any, logits: Any, label_length: Any, logit_length: Any, logits_time_major: bool = ..., unique: Optional[Any] = ..., blank_index: Optional[Any] = ..., name: Optional[Any] = ...): ...
def ctc_loss_dense(labels: Any, logits: Any, label_length: Any, logit_length: Any, logits_time_major: bool = ..., unique: Optional[Any] = ..., blank_index: int = ..., name: Optional[Any] = ...): ...
def collapse_repeated(labels: Any, seq_length: Any, name: Optional[Any] = ...): ...
def dense_labels_to_sparse(dense: Any, length: Any): ...
def ctc_unique_labels(labels: Any, name: Optional[Any] = ...): ...

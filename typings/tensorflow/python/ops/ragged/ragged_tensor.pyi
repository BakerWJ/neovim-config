from tensorflow.python import tf2 as tf2
from tensorflow.python.client import session as session
from tensorflow.python.framework import composite_tensor as composite_tensor, constant_op as constant_op, dtypes as dtypes, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_spec as tensor_spec, tensor_util as tensor_util, type_spec as type_spec
from tensorflow.python.ops import array_ops as array_ops, check_ops as check_ops, control_flow_ops as control_flow_ops, gen_ragged_conversion_ops as gen_ragged_conversion_ops, math_ops as math_ops
from tensorflow.python.ops.ragged import ragged_config as ragged_config, ragged_tensor_value as ragged_tensor_value, ragged_util as ragged_util, segment_id_ops as segment_id_ops
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

class RaggedTensor(composite_tensor.CompositeTensor):
    def __init__(self, values: Any, row_splits: Any, cached_row_lengths: Optional[Any] = ..., cached_value_rowids: Optional[Any] = ..., cached_nrows: Optional[Any] = ..., internal: bool = ..., uniform_row_length: Optional[Any] = ...) -> None: ...
    @classmethod
    def from_value_rowids(cls, values: Any, value_rowids: Any, nrows: Optional[Any] = ..., name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_row_splits(cls, values: Any, row_splits: Any, name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_row_lengths(cls, values: Any, row_lengths: Any, name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_row_starts(cls, values: Any, row_starts: Any, name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_row_limits(cls, values: Any, row_limits: Any, name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_uniform_row_length(cls, values: Any, uniform_row_length: Any, nrows: Optional[Any] = ..., validate: bool = ..., name: Optional[Any] = ...): ...
    @classmethod
    def from_nested_value_rowids(cls, flat_values: Any, nested_value_rowids: Any, nested_nrows: Optional[Any] = ..., name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_nested_row_splits(cls, flat_values: Any, nested_row_splits: Any, name: Optional[Any] = ..., validate: bool = ...): ...
    @classmethod
    def from_nested_row_lengths(cls, flat_values: Any, nested_row_lengths: Any, name: Optional[Any] = ..., validate: bool = ...): ...
    @property
    def dtype(self): ...
    @property
    def shape(self): ...
    @property
    def ragged_rank(self): ...
    @property
    def values(self): ...
    @property
    def row_splits(self): ...
    @property
    def uniform_row_length(self): ...
    @property
    def flat_values(self): ...
    @property
    def nested_row_splits(self): ...
    def value_rowids(self, name: Optional[Any] = ...): ...
    def nested_value_rowids(self, name: Optional[Any] = ...): ...
    def nrows(self, out_type: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def row_starts(self, name: Optional[Any] = ...): ...
    def row_limits(self, name: Optional[Any] = ...): ...
    def row_lengths(self, axis: int = ..., name: Optional[Any] = ...): ...
    def nested_row_lengths(self, name: Optional[Any] = ...): ...
    def bounding_shape(self, axis: Optional[Any] = ..., name: Optional[Any] = ..., out_type: Optional[Any] = ...): ...
    def with_values(self, new_values: Any): ...
    def with_flat_values(self, new_values: Any): ...
    def with_row_splits_dtype(self, dtype: Any): ...
    def merge_dims(self, outer_axis: Any, inner_axis: Any): ...
    @classmethod
    def from_tensor(cls, tensor: Any, lengths: Optional[Any] = ..., padding: Optional[Any] = ..., ragged_rank: int = ..., name: Optional[Any] = ..., row_splits_dtype: Any = ...): ...
    def to_tensor(self, default_value: Optional[Any] = ..., name: Optional[Any] = ..., shape: Optional[Any] = ...): ...
    @classmethod
    def from_sparse(cls, st_input: Any, name: Optional[Any] = ..., row_splits_dtype: Any = ...): ...
    def to_sparse(self, name: Optional[Any] = ...): ...
    def numpy(self): ...
    def to_list(self): ...
    def __getitem__(self, key: Any) -> None: ...
    def consumers(self): ...

def is_ragged(value: Any): ...
def match_row_splits_dtypes(*tensors: Any, **kwargs: Any): ...

class RaggedTensorSpec(type_spec.BatchableTypeSpec):
    @property
    def value_type(self): ...
    def __init__(self, shape: Optional[Any] = ..., dtype: Any = ..., ragged_rank: Optional[Any] = ..., row_splits_dtype: Any = ...) -> None: ...
    @classmethod
    def from_value(cls, value: Any): ...

def convert_to_tensor_or_ragged_tensor(value: Any, dtype: Optional[Any] = ..., preferred_dtype: Optional[Any] = ..., name: Optional[Any] = ...): ...

class RaggedTensorType:
    def __init__(self, dtype: Any, ragged_rank: Any, row_splits_dtype: Any = ...) -> None: ...
    dtype: Any = ...
    ragged_rank: Any = ...
    row_splits_dtype: Any = ...

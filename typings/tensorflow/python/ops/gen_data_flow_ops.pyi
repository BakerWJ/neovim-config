from collections import namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

def accumulator_apply_gradient(handle: Any, local_step: Any, gradient: Any, name: Optional[Any] = ...): ...

AccumulatorApplyGradient: Any

def accumulator_apply_gradient_eager_fallback(handle: Any, local_step: Any, gradient: Any, name: Any, ctx: Any) -> None: ...
def accumulator_num_accumulated(handle: Any, name: Optional[Any] = ...): ...

AccumulatorNumAccumulated: Any

def accumulator_num_accumulated_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...
def accumulator_set_global_step(handle: Any, new_global_step: Any, name: Optional[Any] = ...): ...

AccumulatorSetGlobalStep: Any

def accumulator_set_global_step_eager_fallback(handle: Any, new_global_step: Any, name: Any, ctx: Any) -> None: ...
def accumulator_take_gradient(handle: Any, num_required: Any, dtype: Any, name: Optional[Any] = ...): ...

AccumulatorTakeGradient: Any

def accumulator_take_gradient_eager_fallback(handle: Any, num_required: Any, dtype: Any, name: Any, ctx: Any) -> None: ...
def barrier(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

Barrier: Any

def barrier_eager_fallback(component_types: Any, shapes: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any) -> None: ...
def barrier_close(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...

BarrierClose: Any

def barrier_close_eager_fallback(handle: Any, cancel_pending_enqueues: Any, name: Any, ctx: Any) -> None: ...
def barrier_incomplete_size(handle: Any, name: Optional[Any] = ...): ...

BarrierIncompleteSize: Any

def barrier_incomplete_size_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...
def barrier_insert_many(handle: Any, keys: Any, values: Any, component_index: Any, name: Optional[Any] = ...): ...

BarrierInsertMany: Any

def barrier_insert_many_eager_fallback(handle: Any, keys: Any, values: Any, component_index: Any, name: Any, ctx: Any) -> None: ...
def barrier_ready_size(handle: Any, name: Optional[Any] = ...): ...

BarrierReadySize: Any

def barrier_ready_size_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...

_BarrierTakeManyOutput = namedtuple('BarrierTakeMany', ['indices', 'keys', 'values'])

def barrier_take_many(handle: Any, num_elements: Any, component_types: Any, allow_small_batch: bool = ..., wait_for_incomplete: bool = ..., timeout_ms: int = ..., name: Optional[Any] = ...): ...

BarrierTakeMany: Any

def barrier_take_many_eager_fallback(handle: Any, num_elements: Any, component_types: Any, allow_small_batch: Any, wait_for_incomplete: Any, timeout_ms: Any, name: Any, ctx: Any) -> None: ...
def conditional_accumulator(dtype: Any, shape: Any, container: str = ..., shared_name: str = ..., reduction_type: str = ..., name: Optional[Any] = ...): ...

ConditionalAccumulator: Any

def conditional_accumulator_eager_fallback(dtype: Any, shape: Any, container: Any, shared_name: Any, reduction_type: Any, name: Any, ctx: Any) -> None: ...
def delete_session_tensor(handle: Any, name: Optional[Any] = ...): ...

DeleteSessionTensor: Any

def delete_session_tensor_eager_fallback(handle: Any, name: Any, ctx: Any): ...
def dynamic_partition(data: Any, partitions: Any, num_partitions: Any, name: Optional[Any] = ...): ...

DynamicPartition: Any

def dynamic_partition_eager_fallback(data: Any, partitions: Any, num_partitions: Any, name: Any, ctx: Any): ...
def dynamic_stitch(indices: Any, data: Any, name: Optional[Any] = ...): ...

DynamicStitch: Any

def dynamic_stitch_eager_fallback(indices: Any, data: Any, name: Any, ctx: Any): ...
def fifo_queue(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

FIFOQueue: Any

def fifo_queue_eager_fallback(component_types: Any, shapes: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any) -> None: ...
def fifo_queue_v2(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

FIFOQueueV2: Any

def fifo_queue_v2_eager_fallback(component_types: Any, shapes: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def fake_queue(resource: Any, name: Optional[Any] = ...): ...

FakeQueue: Any

def fake_queue_eager_fallback(resource: Any, name: Any, ctx: Any) -> None: ...
def get_session_handle(value: Any, name: Optional[Any] = ...): ...

GetSessionHandle: Any

def get_session_handle_eager_fallback(value: Any, name: Any, ctx: Any): ...
def get_session_handle_v2(value: Any, name: Optional[Any] = ...): ...

GetSessionHandleV2: Any

def get_session_handle_v2_eager_fallback(value: Any, name: Any, ctx: Any): ...
def get_session_tensor(handle: Any, dtype: Any, name: Optional[Any] = ...): ...

GetSessionTensor: Any

def get_session_tensor_eager_fallback(handle: Any, dtype: Any, name: Any, ctx: Any): ...
def map_clear(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapClear: Any

def map_clear_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def map_incomplete_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapIncompleteSize: Any

def map_incomplete_size_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def map_peek(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapPeek: Any

def map_peek_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def map_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapSize: Any

def map_size_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def map_stage(key: Any, indices: Any, values: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapStage: Any

def map_stage_eager_fallback(key: Any, indices: Any, values: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def map_unstage(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapUnstage: Any

def map_unstage_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...

_MapUnstageNoKeyOutput = namedtuple('MapUnstageNoKey', ['key', 'values'])

def map_unstage_no_key(indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

MapUnstageNoKey: Any

def map_unstage_no_key_eager_fallback(indices: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def ordered_map_clear(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapClear: Any

def ordered_map_clear_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def ordered_map_incomplete_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapIncompleteSize: Any

def ordered_map_incomplete_size_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def ordered_map_peek(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapPeek: Any

def ordered_map_peek_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def ordered_map_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapSize: Any

def ordered_map_size_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def ordered_map_stage(key: Any, indices: Any, values: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapStage: Any

def ordered_map_stage_eager_fallback(key: Any, indices: Any, values: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def ordered_map_unstage(key: Any, indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapUnstage: Any

def ordered_map_unstage_eager_fallback(key: Any, indices: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...

_OrderedMapUnstageNoKeyOutput = namedtuple('OrderedMapUnstageNoKey', ['key', 'values'])

def ordered_map_unstage_no_key(indices: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

OrderedMapUnstageNoKey: Any

def ordered_map_unstage_no_key_eager_fallback(indices: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def padding_fifo_queue(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

PaddingFIFOQueue: Any

def padding_fifo_queue_eager_fallback(component_types: Any, shapes: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any) -> None: ...
def padding_fifo_queue_v2(component_types: Any, shapes: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

PaddingFIFOQueueV2: Any

def padding_fifo_queue_v2_eager_fallback(component_types: Any, shapes: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def parallel_dynamic_stitch(indices: Any, data: Any, name: Optional[Any] = ...): ...

ParallelDynamicStitch: Any

def parallel_dynamic_stitch_eager_fallback(indices: Any, data: Any, name: Any, ctx: Any): ...
def priority_queue(shapes: Any, component_types: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

PriorityQueue: Any

def priority_queue_eager_fallback(shapes: Any, component_types: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any) -> None: ...
def priority_queue_v2(shapes: Any, component_types: Any = ..., capacity: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

PriorityQueueV2: Any

def priority_queue_v2_eager_fallback(shapes: Any, component_types: Any, capacity: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def queue_close(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...

QueueClose: Any

def queue_close_eager_fallback(handle: Any, cancel_pending_enqueues: Any, name: Any, ctx: Any) -> None: ...
def queue_close_v2(handle: Any, cancel_pending_enqueues: bool = ..., name: Optional[Any] = ...): ...

QueueCloseV2: Any

def queue_close_v2_eager_fallback(handle: Any, cancel_pending_enqueues: Any, name: Any, ctx: Any): ...
def queue_dequeue(handle: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueDequeue: Any

def queue_dequeue_eager_fallback(handle: Any, component_types: Any, timeout_ms: Any, name: Any, ctx: Any) -> None: ...
def queue_dequeue_many(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueDequeueMany: Any

def queue_dequeue_many_eager_fallback(handle: Any, n: Any, component_types: Any, timeout_ms: Any, name: Any, ctx: Any) -> None: ...
def queue_dequeue_many_v2(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueDequeueManyV2: Any

def queue_dequeue_many_v2_eager_fallback(handle: Any, n: Any, component_types: Any, timeout_ms: Any, name: Any, ctx: Any): ...
def queue_dequeue_up_to(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueDequeueUpTo: Any

def queue_dequeue_up_to_eager_fallback(handle: Any, n: Any, component_types: Any, timeout_ms: Any, name: Any, ctx: Any) -> None: ...
def queue_dequeue_up_to_v2(handle: Any, n: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueDequeueUpToV2: Any

def queue_dequeue_up_to_v2_eager_fallback(handle: Any, n: Any, component_types: Any, timeout_ms: Any, name: Any, ctx: Any): ...
def queue_dequeue_v2(handle: Any, component_types: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueDequeueV2: Any

def queue_dequeue_v2_eager_fallback(handle: Any, component_types: Any, timeout_ms: Any, name: Any, ctx: Any): ...
def queue_enqueue(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueEnqueue: Any

def queue_enqueue_eager_fallback(handle: Any, components: Any, timeout_ms: Any, name: Any, ctx: Any) -> None: ...
def queue_enqueue_many(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueEnqueueMany: Any

def queue_enqueue_many_eager_fallback(handle: Any, components: Any, timeout_ms: Any, name: Any, ctx: Any) -> None: ...
def queue_enqueue_many_v2(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueEnqueueManyV2: Any

def queue_enqueue_many_v2_eager_fallback(handle: Any, components: Any, timeout_ms: Any, name: Any, ctx: Any): ...
def queue_enqueue_v2(handle: Any, components: Any, timeout_ms: int = ..., name: Optional[Any] = ...): ...

QueueEnqueueV2: Any

def queue_enqueue_v2_eager_fallback(handle: Any, components: Any, timeout_ms: Any, name: Any, ctx: Any): ...
def queue_is_closed(handle: Any, name: Optional[Any] = ...): ...

QueueIsClosed: Any

def queue_is_closed_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...
def queue_is_closed_v2(handle: Any, name: Optional[Any] = ...): ...

QueueIsClosedV2: Any

def queue_is_closed_v2_eager_fallback(handle: Any, name: Any, ctx: Any): ...
def queue_size(handle: Any, name: Optional[Any] = ...): ...

QueueSize: Any

def queue_size_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...
def queue_size_v2(handle: Any, name: Optional[Any] = ...): ...

QueueSizeV2: Any

def queue_size_v2_eager_fallback(handle: Any, name: Any, ctx: Any): ...
def random_shuffle_queue(component_types: Any, shapes: Any = ..., capacity: int = ..., min_after_dequeue: int = ..., seed: int = ..., seed2: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

RandomShuffleQueue: Any

def random_shuffle_queue_eager_fallback(component_types: Any, shapes: Any, capacity: Any, min_after_dequeue: Any, seed: Any, seed2: Any, container: Any, shared_name: Any, name: Any, ctx: Any) -> None: ...
def random_shuffle_queue_v2(component_types: Any, shapes: Any = ..., capacity: int = ..., min_after_dequeue: int = ..., seed: int = ..., seed2: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

RandomShuffleQueueV2: Any

def random_shuffle_queue_v2_eager_fallback(component_types: Any, shapes: Any, capacity: Any, min_after_dequeue: Any, seed: Any, seed2: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def record_input(file_pattern: Any, file_random_seed: int = ..., file_shuffle_shift_ratio: int = ..., file_buffer_size: int = ..., file_parallelism: int = ..., batch_size: int = ..., compression_type: str = ..., name: Optional[Any] = ...): ...

RecordInput: Any

def record_input_eager_fallback(file_pattern: Any, file_random_seed: Any, file_shuffle_shift_ratio: Any, file_buffer_size: Any, file_parallelism: Any, batch_size: Any, compression_type: Any, name: Any, ctx: Any): ...
def resource_accumulator_apply_gradient(handle: Any, local_step: Any, gradient: Any, name: Optional[Any] = ...): ...

ResourceAccumulatorApplyGradient: Any

def resource_accumulator_apply_gradient_eager_fallback(handle: Any, local_step: Any, gradient: Any, name: Any, ctx: Any): ...
def resource_accumulator_num_accumulated(handle: Any, name: Optional[Any] = ...): ...

ResourceAccumulatorNumAccumulated: Any

def resource_accumulator_num_accumulated_eager_fallback(handle: Any, name: Any, ctx: Any): ...
def resource_accumulator_set_global_step(handle: Any, new_global_step: Any, name: Optional[Any] = ...): ...

ResourceAccumulatorSetGlobalStep: Any

def resource_accumulator_set_global_step_eager_fallback(handle: Any, new_global_step: Any, name: Any, ctx: Any): ...
def resource_accumulator_take_gradient(handle: Any, num_required: Any, dtype: Any, name: Optional[Any] = ...): ...

ResourceAccumulatorTakeGradient: Any

def resource_accumulator_take_gradient_eager_fallback(handle: Any, num_required: Any, dtype: Any, name: Any, ctx: Any): ...
def resource_conditional_accumulator(dtype: Any, shape: Any, container: str = ..., shared_name: str = ..., reduction_type: str = ..., name: Optional[Any] = ...): ...

ResourceConditionalAccumulator: Any

def resource_conditional_accumulator_eager_fallback(dtype: Any, shape: Any, container: Any, shared_name: Any, reduction_type: Any, name: Any, ctx: Any): ...
def sparse_accumulator_apply_gradient(handle: Any, local_step: Any, gradient_indices: Any, gradient_values: Any, gradient_shape: Any, has_known_shape: Any, name: Optional[Any] = ...): ...

SparseAccumulatorApplyGradient: Any

def sparse_accumulator_apply_gradient_eager_fallback(handle: Any, local_step: Any, gradient_indices: Any, gradient_values: Any, gradient_shape: Any, has_known_shape: Any, name: Any, ctx: Any) -> None: ...

_SparseAccumulatorTakeGradientOutput = namedtuple('SparseAccumulatorTakeGradient', ['indices', 'values', 'shape'])

def sparse_accumulator_take_gradient(handle: Any, num_required: Any, dtype: Any, name: Optional[Any] = ...): ...

SparseAccumulatorTakeGradient: Any

def sparse_accumulator_take_gradient_eager_fallback(handle: Any, num_required: Any, dtype: Any, name: Any, ctx: Any) -> None: ...
def sparse_conditional_accumulator(dtype: Any, shape: Any, container: str = ..., shared_name: str = ..., reduction_type: str = ..., name: Optional[Any] = ...): ...

SparseConditionalAccumulator: Any

def sparse_conditional_accumulator_eager_fallback(dtype: Any, shape: Any, container: Any, shared_name: Any, reduction_type: Any, name: Any, ctx: Any) -> None: ...

Stack: Any

def stack_close(handle: Any, name: Optional[Any] = ...): ...

StackClose: Any

def stack_close_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...
def stack_close_v2(handle: Any, name: Optional[Any] = ...): ...

StackCloseV2: Any

def stack_close_v2_eager_fallback(handle: Any, name: Any, ctx: Any): ...
def stack_pop(handle: Any, elem_type: Any, name: Optional[Any] = ...): ...

StackPop: Any

def stack_pop_eager_fallback(handle: Any, elem_type: Any, name: Any, ctx: Any) -> None: ...
def stack_pop_v2(handle: Any, elem_type: Any, name: Optional[Any] = ...): ...

StackPopV2: Any

def stack_pop_v2_eager_fallback(handle: Any, elem_type: Any, name: Any, ctx: Any): ...
def stack_push(handle: Any, elem: Any, swap_memory: bool = ..., name: Optional[Any] = ...): ...

StackPush: Any

def stack_push_eager_fallback(handle: Any, elem: Any, swap_memory: Any, name: Any, ctx: Any) -> None: ...
def stack_push_v2(handle: Any, elem: Any, swap_memory: bool = ..., name: Optional[Any] = ...): ...

StackPushV2: Any

def stack_push_v2_eager_fallback(handle: Any, elem: Any, swap_memory: Any, name: Any, ctx: Any): ...
def stack_v2(max_size: Any, elem_type: Any, stack_name: str = ..., name: Optional[Any] = ...): ...

StackV2: Any

def stack_v2_eager_fallback(max_size: Any, elem_type: Any, stack_name: Any, name: Any, ctx: Any): ...
def stage(values: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

Stage: Any

def stage_eager_fallback(values: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def stage_clear(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

StageClear: Any

def stage_clear_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def stage_peek(index: Any, dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

StagePeek: Any

def stage_peek_eager_fallback(index: Any, dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def stage_size(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

StageSize: Any

def stage_size_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...
def tensor_array(size: Any, dtype: Any, dynamic_size: bool = ..., clear_after_read: bool = ..., tensor_array_name: str = ..., element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArray: Any

def tensor_array_eager_fallback(size: Any, dtype: Any, dynamic_size: Any, clear_after_read: Any, tensor_array_name: Any, element_shape: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_close(handle: Any, name: Optional[Any] = ...): ...

TensorArrayClose: Any

def tensor_array_close_eager_fallback(handle: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_close_v2(handle: Any, name: Optional[Any] = ...): ...

TensorArrayCloseV2: Any

def tensor_array_close_v2_eager_fallback(handle: Any, name: Any, ctx: Any): ...
def tensor_array_close_v3(handle: Any, name: Optional[Any] = ...): ...

TensorArrayCloseV3: Any

def tensor_array_close_v3_eager_fallback(handle: Any, name: Any, ctx: Any): ...

_TensorArrayConcatOutput = namedtuple('TensorArrayConcat', ['value', 'lengths'])

def tensor_array_concat(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayConcat: Any

def tensor_array_concat_eager_fallback(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Any, name: Any, ctx: Any) -> None: ...

_TensorArrayConcatV2Output = namedtuple('TensorArrayConcatV2', ['value', 'lengths'])

def tensor_array_concat_v2(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayConcatV2: Any

def tensor_array_concat_v2_eager_fallback(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Any, name: Any, ctx: Any): ...

_TensorArrayConcatV3Output = namedtuple('TensorArrayConcatV3', ['value', 'lengths'])

def tensor_array_concat_v3(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayConcatV3: Any

def tensor_array_concat_v3_eager_fallback(handle: Any, flow_in: Any, dtype: Any, element_shape_except0: Any, name: Any, ctx: Any): ...
def tensor_array_gather(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayGather: Any

def tensor_array_gather_eager_fallback(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_gather_v2(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayGatherV2: Any

def tensor_array_gather_v2_eager_fallback(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Any, name: Any, ctx: Any): ...
def tensor_array_gather_v3(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayGatherV3: Any

def tensor_array_gather_v3_eager_fallback(handle: Any, indices: Any, flow_in: Any, dtype: Any, element_shape: Any, name: Any, ctx: Any): ...
def tensor_array_grad(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ...): ...

TensorArrayGrad: Any

def tensor_array_grad_eager_fallback(handle: Any, flow_in: Any, source: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_grad_v2(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ...): ...

TensorArrayGradV2: Any

def tensor_array_grad_v2_eager_fallback(handle: Any, flow_in: Any, source: Any, name: Any, ctx: Any): ...

_TensorArrayGradV3Output = namedtuple('TensorArrayGradV3', ['grad_handle', 'flow_out'])

def tensor_array_grad_v3(handle: Any, flow_in: Any, source: Any, name: Optional[Any] = ...): ...

TensorArrayGradV3: Any

def tensor_array_grad_v3_eager_fallback(handle: Any, flow_in: Any, source: Any, name: Any, ctx: Any): ...

_TensorArrayGradWithShapeOutput = namedtuple('TensorArrayGradWithShape', ['grad_handle', 'flow_out'])

def tensor_array_grad_with_shape(handle: Any, flow_in: Any, shape_to_prepend: Any, source: Any, name: Optional[Any] = ...): ...

TensorArrayGradWithShape: Any

def tensor_array_grad_with_shape_eager_fallback(handle: Any, flow_in: Any, shape_to_prepend: Any, source: Any, name: Any, ctx: Any): ...
def tensor_array_pack(handle: Any, flow_in: Any, dtype: Any, element_shape: Optional[Any] = ..., name: Optional[Any] = ...): ...

TensorArrayPack: Any

def tensor_array_pack_eager_fallback(handle: Any, flow_in: Any, dtype: Any, element_shape: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_read(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ...): ...

TensorArrayRead: Any

def tensor_array_read_eager_fallback(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_read_v2(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ...): ...

TensorArrayReadV2: Any

def tensor_array_read_v2_eager_fallback(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Any, ctx: Any): ...
def tensor_array_read_v3(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Optional[Any] = ...): ...

TensorArrayReadV3: Any

def tensor_array_read_v3_eager_fallback(handle: Any, index: Any, flow_in: Any, dtype: Any, name: Any, ctx: Any): ...
def tensor_array_scatter(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayScatter: Any

def tensor_array_scatter_eager_fallback(handle: Any, indices: Any, value: Any, flow_in: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_scatter_v2(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayScatterV2: Any

def tensor_array_scatter_v2_eager_fallback(handle: Any, indices: Any, value: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_scatter_v3(handle: Any, indices: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayScatterV3: Any

def tensor_array_scatter_v3_eager_fallback(handle: Any, indices: Any, value: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_size(handle: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArraySize: Any

def tensor_array_size_eager_fallback(handle: Any, flow_in: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_size_v2(handle: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArraySizeV2: Any

def tensor_array_size_v2_eager_fallback(handle: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_size_v3(handle: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArraySizeV3: Any

def tensor_array_size_v3_eager_fallback(handle: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_split(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArraySplit: Any

def tensor_array_split_eager_fallback(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_split_v2(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArraySplitV2: Any

def tensor_array_split_v2_eager_fallback(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_split_v3(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArraySplitV3: Any

def tensor_array_split_v3_eager_fallback(handle: Any, value: Any, lengths: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_unpack(handle: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayUnpack: Any

def tensor_array_unpack_eager_fallback(handle: Any, value: Any, flow_in: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_v2(size: Any, dtype: Any, element_shape: Optional[Any] = ..., dynamic_size: bool = ..., clear_after_read: bool = ..., tensor_array_name: str = ..., name: Optional[Any] = ...): ...

TensorArrayV2: Any

def tensor_array_v2_eager_fallback(size: Any, dtype: Any, element_shape: Any, dynamic_size: Any, clear_after_read: Any, tensor_array_name: Any, name: Any, ctx: Any): ...

_TensorArrayV3Output = namedtuple('TensorArrayV3', ['handle', 'flow'])

def tensor_array_v3(size: Any, dtype: Any, element_shape: Optional[Any] = ..., dynamic_size: bool = ..., clear_after_read: bool = ..., identical_element_shapes: bool = ..., tensor_array_name: str = ..., name: Optional[Any] = ...): ...

TensorArrayV3: Any

def tensor_array_v3_eager_fallback(size: Any, dtype: Any, element_shape: Any, dynamic_size: Any, clear_after_read: Any, identical_element_shapes: Any, tensor_array_name: Any, name: Any, ctx: Any): ...
def tensor_array_write(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayWrite: Any

def tensor_array_write_eager_fallback(handle: Any, index: Any, value: Any, flow_in: Any, name: Any, ctx: Any) -> None: ...
def tensor_array_write_v2(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayWriteV2: Any

def tensor_array_write_v2_eager_fallback(handle: Any, index: Any, value: Any, flow_in: Any, name: Any, ctx: Any): ...
def tensor_array_write_v3(handle: Any, index: Any, value: Any, flow_in: Any, name: Optional[Any] = ...): ...

TensorArrayWriteV3: Any

def tensor_array_write_v3_eager_fallback(handle: Any, index: Any, value: Any, flow_in: Any, name: Any, ctx: Any): ...
def unstage(dtypes: Any, capacity: int = ..., memory_limit: int = ..., container: str = ..., shared_name: str = ..., name: Optional[Any] = ...): ...

Unstage: Any

def unstage_eager_fallback(dtypes: Any, capacity: Any, memory_limit: Any, container: Any, shared_name: Any, name: Any, ctx: Any): ...

from collections import namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

def batch_matrix_band_part(input: Any, num_lower: Any, num_upper: Any, name: Optional[Any] = ...): ...

BatchMatrixBandPart: Any

def batch_matrix_band_part_eager_fallback(input: Any, num_lower: Any, num_upper: Any, name: Any, ctx: Any): ...
def batch_matrix_diag(diagonal: Any, name: Optional[Any] = ...): ...

BatchMatrixDiag: Any

def batch_matrix_diag_eager_fallback(diagonal: Any, name: Any, ctx: Any): ...
def batch_matrix_diag_part(input: Any, name: Optional[Any] = ...): ...

BatchMatrixDiagPart: Any

def batch_matrix_diag_part_eager_fallback(input: Any, name: Any, ctx: Any): ...
def batch_matrix_set_diag(input: Any, diagonal: Any, name: Optional[Any] = ...): ...

BatchMatrixSetDiag: Any

def batch_matrix_set_diag_eager_fallback(input: Any, diagonal: Any, name: Any, ctx: Any): ...
def batch_to_space(input: Any, crops: Any, block_size: Any, name: Optional[Any] = ...): ...

BatchToSpace: Any

def batch_to_space_eager_fallback(input: Any, crops: Any, block_size: Any, name: Any, ctx: Any): ...
def batch_to_space_nd(input: Any, block_shape: Any, crops: Any, name: Optional[Any] = ...): ...

BatchToSpaceND: Any

def batch_to_space_nd_eager_fallback(input: Any, block_shape: Any, crops: Any, name: Any, ctx: Any): ...
def bitcast(input: Any, type: Any, name: Optional[Any] = ...): ...

Bitcast: Any

def bitcast_eager_fallback(input: Any, type: Any, name: Any, ctx: Any): ...
def broadcast_args(s0: Any, s1: Any, name: Optional[Any] = ...): ...

BroadcastArgs: Any

def broadcast_args_eager_fallback(s0: Any, s1: Any, name: Any, ctx: Any): ...

_BroadcastGradientArgsOutput = namedtuple('BroadcastGradientArgs', ['r0', 'r1'])

def broadcast_gradient_args(s0: Any, s1: Any, name: Optional[Any] = ...): ...

BroadcastGradientArgs: Any

def broadcast_gradient_args_eager_fallback(s0: Any, s1: Any, name: Any, ctx: Any): ...
def broadcast_to(input: Any, shape: Any, name: Optional[Any] = ...): ...

BroadcastTo: Any

def broadcast_to_eager_fallback(input: Any, shape: Any, name: Any, ctx: Any): ...
def check_numerics(tensor: Any, message: Any, name: Optional[Any] = ...): ...

CheckNumerics: Any

def check_numerics_eager_fallback(tensor: Any, message: Any, name: Any, ctx: Any): ...
def check_numerics_v2(tensor: Any, message: Any, name: Optional[Any] = ...): ...

CheckNumericsV2: Any

def check_numerics_v2_eager_fallback(tensor: Any, message: Any, name: Any, ctx: Any): ...
def concat(concat_dim: Any, values: Any, name: Optional[Any] = ...): ...

Concat: Any

def concat_eager_fallback(concat_dim: Any, values: Any, name: Any, ctx: Any): ...
def concat_offset(concat_dim: Any, shape: Any, name: Optional[Any] = ...): ...

ConcatOffset: Any

def concat_offset_eager_fallback(concat_dim: Any, shape: Any, name: Any, ctx: Any): ...
def concat_v2(values: Any, axis: Any, name: Optional[Any] = ...): ...

ConcatV2: Any

def concat_v2_eager_fallback(values: Any, axis: Any, name: Any, ctx: Any): ...
def conjugate_transpose(x: Any, perm: Any, name: Optional[Any] = ...): ...

ConjugateTranspose: Any

def conjugate_transpose_eager_fallback(x: Any, perm: Any, name: Any, ctx: Any): ...
def const(value: Any, dtype: Any, name: Optional[Any] = ...): ...

Const: Any

def const_eager_fallback(value: Any, dtype: Any, name: Any, ctx: Any): ...
def debug_gradient_identity(input: Any, name: Optional[Any] = ...): ...

DebugGradientIdentity: Any

def debug_gradient_identity_eager_fallback(input: Any, name: Any, ctx: Any): ...
def debug_gradient_ref_identity(input: Any, name: Optional[Any] = ...): ...

DebugGradientRefIdentity: Any

def debug_gradient_ref_identity_eager_fallback(input: Any, name: Any, ctx: Any) -> None: ...
def deep_copy(x: Any, name: Optional[Any] = ...): ...

DeepCopy: Any

def deep_copy_eager_fallback(x: Any, name: Any, ctx: Any): ...
def depth_to_space(input: Any, block_size: Any, data_format: str = ..., name: Optional[Any] = ...): ...

DepthToSpace: Any

def depth_to_space_eager_fallback(input: Any, block_size: Any, data_format: Any, name: Any, ctx: Any): ...
def dequantize(input: Any, min_range: Any, max_range: Any, mode: str = ..., narrow_range: bool = ..., axis: int = ..., dtype: Any = ..., name: Optional[Any] = ...): ...

Dequantize: Any

def dequantize_eager_fallback(input: Any, min_range: Any, max_range: Any, mode: Any, narrow_range: Any, axis: Any, dtype: Any, name: Any, ctx: Any): ...
def diag(diagonal: Any, name: Optional[Any] = ...): ...

Diag: Any

def diag_eager_fallback(diagonal: Any, name: Any, ctx: Any): ...
def diag_part(input: Any, name: Optional[Any] = ...): ...

DiagPart: Any

def diag_part_eager_fallback(input: Any, name: Any, ctx: Any): ...
def edit_distance(hypothesis_indices: Any, hypothesis_values: Any, hypothesis_shape: Any, truth_indices: Any, truth_values: Any, truth_shape: Any, normalize: bool = ..., name: Optional[Any] = ...): ...

EditDistance: Any

def edit_distance_eager_fallback(hypothesis_indices: Any, hypothesis_values: Any, hypothesis_shape: Any, truth_indices: Any, truth_values: Any, truth_shape: Any, normalize: Any, name: Any, ctx: Any): ...
def empty(shape: Any, dtype: Any, init: bool = ..., name: Optional[Any] = ...): ...

Empty: Any

def empty_eager_fallback(shape: Any, dtype: Any, init: Any, name: Any, ctx: Any): ...
def ensure_shape(input: Any, shape: Any, name: Optional[Any] = ...): ...

EnsureShape: Any

def ensure_shape_eager_fallback(input: Any, shape: Any, name: Any, ctx: Any): ...
def expand_dims(input: Any, axis: Any, name: Optional[Any] = ...): ...

ExpandDims: Any

def expand_dims_eager_fallback(input: Any, axis: Any, name: Any, ctx: Any): ...
def extract_image_patches(images: Any, ksizes: Any, strides: Any, rates: Any, padding: Any, name: Optional[Any] = ...): ...

ExtractImagePatches: Any

def extract_image_patches_eager_fallback(images: Any, ksizes: Any, strides: Any, rates: Any, padding: Any, name: Any, ctx: Any): ...
def extract_volume_patches(input: Any, ksizes: Any, strides: Any, padding: Any, name: Optional[Any] = ...): ...

ExtractVolumePatches: Any

def extract_volume_patches_eager_fallback(input: Any, ksizes: Any, strides: Any, padding: Any, name: Any, ctx: Any): ...
def fake_quant_with_min_max_args(inputs: Any, min: int = ..., max: int = ..., num_bits: int = ..., narrow_range: bool = ..., name: Optional[Any] = ...): ...

FakeQuantWithMinMaxArgs: Any

def fake_quant_with_min_max_args_eager_fallback(inputs: Any, min: Any, max: Any, num_bits: Any, narrow_range: Any, name: Any, ctx: Any): ...
def fake_quant_with_min_max_args_gradient(gradients: Any, inputs: Any, min: int = ..., max: int = ..., num_bits: int = ..., narrow_range: bool = ..., name: Optional[Any] = ...): ...

FakeQuantWithMinMaxArgsGradient: Any

def fake_quant_with_min_max_args_gradient_eager_fallback(gradients: Any, inputs: Any, min: Any, max: Any, num_bits: Any, narrow_range: Any, name: Any, ctx: Any): ...
def fake_quant_with_min_max_vars(inputs: Any, min: Any, max: Any, num_bits: int = ..., narrow_range: bool = ..., name: Optional[Any] = ...): ...

FakeQuantWithMinMaxVars: Any

def fake_quant_with_min_max_vars_eager_fallback(inputs: Any, min: Any, max: Any, num_bits: Any, narrow_range: Any, name: Any, ctx: Any): ...

_FakeQuantWithMinMaxVarsGradientOutput = namedtuple('FakeQuantWithMinMaxVarsGradient', ['backprops_wrt_input', 'backprop_wrt_min', 'backprop_wrt_max'])

def fake_quant_with_min_max_vars_gradient(gradients: Any, inputs: Any, min: Any, max: Any, num_bits: int = ..., narrow_range: bool = ..., name: Optional[Any] = ...): ...

FakeQuantWithMinMaxVarsGradient: Any

def fake_quant_with_min_max_vars_gradient_eager_fallback(gradients: Any, inputs: Any, min: Any, max: Any, num_bits: Any, narrow_range: Any, name: Any, ctx: Any): ...
def fake_quant_with_min_max_vars_per_channel(inputs: Any, min: Any, max: Any, num_bits: int = ..., narrow_range: bool = ..., name: Optional[Any] = ...): ...

FakeQuantWithMinMaxVarsPerChannel: Any

def fake_quant_with_min_max_vars_per_channel_eager_fallback(inputs: Any, min: Any, max: Any, num_bits: Any, narrow_range: Any, name: Any, ctx: Any): ...

_FakeQuantWithMinMaxVarsPerChannelGradientOutput = namedtuple('FakeQuantWithMinMaxVarsPerChannelGradient', ['backprops_wrt_input', 'backprop_wrt_min', 'backprop_wrt_max'])

def fake_quant_with_min_max_vars_per_channel_gradient(gradients: Any, inputs: Any, min: Any, max: Any, num_bits: int = ..., narrow_range: bool = ..., name: Optional[Any] = ...): ...

FakeQuantWithMinMaxVarsPerChannelGradient: Any

def fake_quant_with_min_max_vars_per_channel_gradient_eager_fallback(gradients: Any, inputs: Any, min: Any, max: Any, num_bits: Any, narrow_range: Any, name: Any, ctx: Any): ...
def fill(dims: Any, value: Any, name: Optional[Any] = ...): ...

Fill: Any

def fill_eager_fallback(dims: Any, value: Any, name: Any, ctx: Any): ...
def fingerprint(data: Any, method: Any, name: Optional[Any] = ...): ...

Fingerprint: Any

def fingerprint_eager_fallback(data: Any, method: Any, name: Any, ctx: Any): ...
def gather(params: Any, indices: Any, validate_indices: bool = ..., name: Optional[Any] = ...): ...

Gather: Any

def gather_eager_fallback(params: Any, indices: Any, validate_indices: Any, name: Any, ctx: Any): ...
def gather_nd(params: Any, indices: Any, name: Optional[Any] = ...): ...

GatherNd: Any

def gather_nd_eager_fallback(params: Any, indices: Any, name: Any, ctx: Any): ...
def gather_v2(params: Any, indices: Any, axis: Any, batch_dims: int = ..., name: Optional[Any] = ...): ...

GatherV2: Any

def gather_v2_eager_fallback(params: Any, indices: Any, axis: Any, batch_dims: Any, name: Any, ctx: Any): ...
def guarantee_const(input: Any, name: Optional[Any] = ...): ...

GuaranteeConst: Any

def guarantee_const_eager_fallback(input: Any, name: Any, ctx: Any): ...
def identity(input: Any, name: Optional[Any] = ...): ...

Identity: Any

def identity_eager_fallback(input: Any, name: Any, ctx: Any): ...
def identity_n(input: Any, name: Optional[Any] = ...): ...

IdentityN: Any

def identity_n_eager_fallback(input: Any, name: Any, ctx: Any): ...
def immutable_const(dtype: Any, shape: Any, memory_region_name: Any, name: Optional[Any] = ...): ...

ImmutableConst: Any

def immutable_const_eager_fallback(dtype: Any, shape: Any, memory_region_name: Any, name: Any, ctx: Any): ...
def inplace_add(x: Any, i: Any, v: Any, name: Optional[Any] = ...): ...

InplaceAdd: Any

def inplace_add_eager_fallback(x: Any, i: Any, v: Any, name: Any, ctx: Any): ...
def inplace_sub(x: Any, i: Any, v: Any, name: Optional[Any] = ...): ...

InplaceSub: Any

def inplace_sub_eager_fallback(x: Any, i: Any, v: Any, name: Any, ctx: Any): ...
def inplace_update(x: Any, i: Any, v: Any, name: Optional[Any] = ...): ...

InplaceUpdate: Any

def inplace_update_eager_fallback(x: Any, i: Any, v: Any, name: Any, ctx: Any): ...
def invert_permutation(x: Any, name: Optional[Any] = ...): ...

InvertPermutation: Any

def invert_permutation_eager_fallback(x: Any, name: Any, ctx: Any): ...

_ListDiffOutput = namedtuple('ListDiff', ['out', 'idx'])

def list_diff(x: Any, y: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...

ListDiff: Any

def list_diff_eager_fallback(x: Any, y: Any, out_idx: Any, name: Any, ctx: Any): ...
def lower_bound(sorted_inputs: Any, values: Any, out_type: Any = ..., name: Optional[Any] = ...): ...

LowerBound: Any

def lower_bound_eager_fallback(sorted_inputs: Any, values: Any, out_type: Any, name: Any, ctx: Any): ...
def matrix_band_part(input: Any, num_lower: Any, num_upper: Any, name: Optional[Any] = ...): ...

MatrixBandPart: Any

def matrix_band_part_eager_fallback(input: Any, num_lower: Any, num_upper: Any, name: Any, ctx: Any): ...
def matrix_diag(diagonal: Any, name: Optional[Any] = ...): ...

MatrixDiag: Any

def matrix_diag_eager_fallback(diagonal: Any, name: Any, ctx: Any): ...
def matrix_diag_part(input: Any, name: Optional[Any] = ...): ...

MatrixDiagPart: Any

def matrix_diag_part_eager_fallback(input: Any, name: Any, ctx: Any): ...
def matrix_diag_part_v2(input: Any, k: Any, padding_value: Any, name: Optional[Any] = ...): ...

MatrixDiagPartV2: Any

def matrix_diag_part_v2_eager_fallback(input: Any, k: Any, padding_value: Any, name: Any, ctx: Any): ...
def matrix_diag_part_v3(input: Any, k: Any, padding_value: Any, align: str = ..., name: Optional[Any] = ...): ...

MatrixDiagPartV3: Any

def matrix_diag_part_v3_eager_fallback(input: Any, k: Any, padding_value: Any, align: Any, name: Any, ctx: Any): ...
def matrix_diag_v2(diagonal: Any, k: Any, num_rows: Any, num_cols: Any, padding_value: Any, name: Optional[Any] = ...): ...

MatrixDiagV2: Any

def matrix_diag_v2_eager_fallback(diagonal: Any, k: Any, num_rows: Any, num_cols: Any, padding_value: Any, name: Any, ctx: Any): ...
def matrix_diag_v3(diagonal: Any, k: Any, num_rows: Any, num_cols: Any, padding_value: Any, align: str = ..., name: Optional[Any] = ...): ...

MatrixDiagV3: Any

def matrix_diag_v3_eager_fallback(diagonal: Any, k: Any, num_rows: Any, num_cols: Any, padding_value: Any, align: Any, name: Any, ctx: Any): ...
def matrix_set_diag(input: Any, diagonal: Any, name: Optional[Any] = ...): ...

MatrixSetDiag: Any

def matrix_set_diag_eager_fallback(input: Any, diagonal: Any, name: Any, ctx: Any): ...
def matrix_set_diag_v2(input: Any, diagonal: Any, k: Any, name: Optional[Any] = ...): ...

MatrixSetDiagV2: Any

def matrix_set_diag_v2_eager_fallback(input: Any, diagonal: Any, k: Any, name: Any, ctx: Any): ...
def matrix_set_diag_v3(input: Any, diagonal: Any, k: Any, align: str = ..., name: Optional[Any] = ...): ...

MatrixSetDiagV3: Any

def matrix_set_diag_v3_eager_fallback(input: Any, diagonal: Any, k: Any, align: Any, name: Any, ctx: Any): ...
def mirror_pad(input: Any, paddings: Any, mode: Any, name: Optional[Any] = ...): ...

MirrorPad: Any

def mirror_pad_eager_fallback(input: Any, paddings: Any, mode: Any, name: Any, ctx: Any): ...
def mirror_pad_grad(input: Any, paddings: Any, mode: Any, name: Optional[Any] = ...): ...

MirrorPadGrad: Any

def mirror_pad_grad_eager_fallback(input: Any, paddings: Any, mode: Any, name: Any, ctx: Any): ...
def one_hot(indices: Any, depth: Any, on_value: Any, off_value: Any, axis: int = ..., name: Optional[Any] = ...): ...

OneHot: Any

def one_hot_eager_fallback(indices: Any, depth: Any, on_value: Any, off_value: Any, axis: Any, name: Any, ctx: Any): ...
def ones_like(x: Any, name: Optional[Any] = ...): ...

OnesLike: Any

def ones_like_eager_fallback(x: Any, name: Any, ctx: Any): ...
def pack(values: Any, axis: int = ..., name: Optional[Any] = ...): ...

Pack: Any

def pack_eager_fallback(values: Any, axis: Any, name: Any, ctx: Any): ...
def pad(input: Any, paddings: Any, name: Optional[Any] = ...): ...

Pad: Any

def pad_eager_fallback(input: Any, paddings: Any, name: Any, ctx: Any): ...
def pad_v2(input: Any, paddings: Any, constant_values: Any, name: Optional[Any] = ...): ...

PadV2: Any

def pad_v2_eager_fallback(input: Any, paddings: Any, constant_values: Any, name: Any, ctx: Any): ...
def parallel_concat(values: Any, shape: Any, name: Optional[Any] = ...): ...

ParallelConcat: Any

def parallel_concat_eager_fallback(values: Any, shape: Any, name: Any, ctx: Any): ...
def placeholder(dtype: Any, shape: Optional[Any] = ..., name: Optional[Any] = ...): ...

Placeholder: Any

def placeholder_eager_fallback(dtype: Any, shape: Any, name: Any, ctx: Any): ...
def placeholder_v2(dtype: Any, shape: Any, name: Optional[Any] = ...): ...

PlaceholderV2: Any

def placeholder_v2_eager_fallback(dtype: Any, shape: Any, name: Any, ctx: Any): ...
def placeholder_with_default(input: Any, shape: Any, name: Optional[Any] = ...): ...

PlaceholderWithDefault: Any

def placeholder_with_default_eager_fallback(input: Any, shape: Any, name: Any, ctx: Any): ...
def prevent_gradient(input: Any, message: str = ..., name: Optional[Any] = ...): ...

PreventGradient: Any

def prevent_gradient_eager_fallback(input: Any, message: Any, name: Any, ctx: Any): ...
def quantize_and_dequantize(input: Any, signed_input: bool = ..., num_bits: int = ..., range_given: bool = ..., input_min: int = ..., input_max: int = ..., name: Optional[Any] = ...): ...

QuantizeAndDequantize: Any

def quantize_and_dequantize_eager_fallback(input: Any, signed_input: Any, num_bits: Any, range_given: Any, input_min: Any, input_max: Any, name: Any, ctx: Any): ...
def quantize_and_dequantize_v2(input: Any, input_min: Any, input_max: Any, signed_input: bool = ..., num_bits: int = ..., range_given: bool = ..., round_mode: str = ..., narrow_range: bool = ..., axis: int = ..., name: Optional[Any] = ...): ...

QuantizeAndDequantizeV2: Any

def quantize_and_dequantize_v2_eager_fallback(input: Any, input_min: Any, input_max: Any, signed_input: Any, num_bits: Any, range_given: Any, round_mode: Any, narrow_range: Any, axis: Any, name: Any, ctx: Any): ...
def quantize_and_dequantize_v3(input: Any, input_min: Any, input_max: Any, num_bits: Any, signed_input: bool = ..., range_given: bool = ..., narrow_range: bool = ..., axis: int = ..., name: Optional[Any] = ...): ...

QuantizeAndDequantizeV3: Any

def quantize_and_dequantize_v3_eager_fallback(input: Any, input_min: Any, input_max: Any, num_bits: Any, signed_input: Any, range_given: Any, narrow_range: Any, axis: Any, name: Any, ctx: Any): ...

_QuantizeV2Output = namedtuple('QuantizeV2', ['output', 'output_min', 'output_max'])

def quantize_v2(input: Any, min_range: Any, max_range: Any, T: Any, mode: str = ..., round_mode: str = ..., narrow_range: bool = ..., axis: int = ..., ensure_minimum_range: float = ..., name: Optional[Any] = ...): ...

QuantizeV2: Any

def quantize_v2_eager_fallback(input: Any, min_range: Any, max_range: Any, T: Any, mode: Any, round_mode: Any, narrow_range: Any, axis: Any, ensure_minimum_range: Any, name: Any, ctx: Any): ...

_QuantizedConcatOutput = namedtuple('QuantizedConcat', ['output', 'output_min', 'output_max'])

def quantized_concat(concat_dim: Any, values: Any, input_mins: Any, input_maxes: Any, name: Optional[Any] = ...): ...

QuantizedConcat: Any

def quantized_concat_eager_fallback(concat_dim: Any, values: Any, input_mins: Any, input_maxes: Any, name: Any, ctx: Any): ...

_QuantizedInstanceNormOutput = namedtuple('QuantizedInstanceNorm', ['y', 'y_min', 'y_max'])

def quantized_instance_norm(x: Any, x_min: Any, x_max: Any, output_range_given: bool = ..., given_y_min: int = ..., given_y_max: int = ..., variance_epsilon: float = ..., min_separation: float = ..., name: Optional[Any] = ...): ...

QuantizedInstanceNorm: Any

def quantized_instance_norm_eager_fallback(x: Any, x_min: Any, x_max: Any, output_range_given: Any, given_y_min: Any, given_y_max: Any, variance_epsilon: Any, min_separation: Any, name: Any, ctx: Any): ...

_QuantizedReshapeOutput = namedtuple('QuantizedReshape', ['output', 'output_min', 'output_max'])

def quantized_reshape(tensor: Any, shape: Any, input_min: Any, input_max: Any, name: Optional[Any] = ...): ...

QuantizedReshape: Any

def quantized_reshape_eager_fallback(tensor: Any, shape: Any, input_min: Any, input_max: Any, name: Any, ctx: Any): ...
def rank(input: Any, name: Optional[Any] = ...): ...

Rank: Any

def rank_eager_fallback(input: Any, name: Any, ctx: Any): ...
def ref_identity(input: Any, name: Optional[Any] = ...): ...

RefIdentity: Any

def ref_identity_eager_fallback(input: Any, name: Any, ctx: Any) -> None: ...
def reshape(tensor: Any, shape: Any, name: Optional[Any] = ...): ...

Reshape: Any

def reshape_eager_fallback(tensor: Any, shape: Any, name: Any, ctx: Any): ...
def resource_strided_slice_assign(ref: Any, begin: Any, end: Any, strides: Any, value: Any, begin_mask: int = ..., end_mask: int = ..., ellipsis_mask: int = ..., new_axis_mask: int = ..., shrink_axis_mask: int = ..., name: Optional[Any] = ...): ...

ResourceStridedSliceAssign: Any

def resource_strided_slice_assign_eager_fallback(ref: Any, begin: Any, end: Any, strides: Any, value: Any, begin_mask: Any, end_mask: Any, ellipsis_mask: Any, new_axis_mask: Any, shrink_axis_mask: Any, name: Any, ctx: Any): ...
def reverse(tensor: Any, dims: Any, name: Optional[Any] = ...): ...

Reverse: Any

def reverse_eager_fallback(tensor: Any, dims: Any, name: Any, ctx: Any): ...
def reverse_sequence(input: Any, seq_lengths: Any, seq_dim: Any, batch_dim: int = ..., name: Optional[Any] = ...): ...

ReverseSequence: Any

def reverse_sequence_eager_fallback(input: Any, seq_lengths: Any, seq_dim: Any, batch_dim: Any, name: Any, ctx: Any): ...
def reverse_v2(tensor: Any, axis: Any, name: Optional[Any] = ...): ...

ReverseV2: Any

def reverse_v2_eager_fallback(tensor: Any, axis: Any, name: Any, ctx: Any): ...
def scatter_nd(indices: Any, updates: Any, shape: Any, name: Optional[Any] = ...): ...

ScatterNd: Any

def scatter_nd_eager_fallback(indices: Any, updates: Any, shape: Any, name: Any, ctx: Any): ...
def scatter_nd_non_aliasing_add(input: Any, indices: Any, updates: Any, name: Optional[Any] = ...): ...

ScatterNdNonAliasingAdd: Any

def scatter_nd_non_aliasing_add_eager_fallback(input: Any, indices: Any, updates: Any, name: Any, ctx: Any): ...
def shape(input: Any, out_type: Any = ..., name: Optional[Any] = ...): ...

Shape: Any

def shape_eager_fallback(input: Any, out_type: Any, name: Any, ctx: Any): ...
def shape_n(input: Any, out_type: Any = ..., name: Optional[Any] = ...): ...

ShapeN: Any

def shape_n_eager_fallback(input: Any, out_type: Any, name: Any, ctx: Any): ...
def size(input: Any, out_type: Any = ..., name: Optional[Any] = ...): ...

Size: Any

def size_eager_fallback(input: Any, out_type: Any, name: Any, ctx: Any): ...

Slice: Any

def snapshot(input: Any, name: Optional[Any] = ...): ...

Snapshot: Any

def snapshot_eager_fallback(input: Any, name: Any, ctx: Any): ...
def space_to_batch(input: Any, paddings: Any, block_size: Any, name: Optional[Any] = ...): ...

SpaceToBatch: Any

def space_to_batch_eager_fallback(input: Any, paddings: Any, block_size: Any, name: Any, ctx: Any): ...
def space_to_batch_nd(input: Any, block_shape: Any, paddings: Any, name: Optional[Any] = ...): ...

SpaceToBatchND: Any

def space_to_batch_nd_eager_fallback(input: Any, block_shape: Any, paddings: Any, name: Any, ctx: Any): ...
def space_to_depth(input: Any, block_size: Any, data_format: str = ..., name: Optional[Any] = ...): ...

SpaceToDepth: Any

def space_to_depth_eager_fallback(input: Any, block_size: Any, data_format: Any, name: Any, ctx: Any): ...
def split(axis: Any, value: Any, num_split: Any, name: Optional[Any] = ...): ...

Split: Any

def split_eager_fallback(axis: Any, value: Any, num_split: Any, name: Any, ctx: Any): ...
def split_v(value: Any, size_splits: Any, axis: Any, num_split: Any, name: Optional[Any] = ...): ...

SplitV: Any

def split_v_eager_fallback(value: Any, size_splits: Any, axis: Any, num_split: Any, name: Any, ctx: Any): ...
def squeeze(input: Any, axis: Any = ..., name: Optional[Any] = ...): ...

Squeeze: Any

def squeeze_eager_fallback(input: Any, axis: Any, name: Any, ctx: Any): ...
def stop_gradient(input: Any, name: Optional[Any] = ...): ...

StopGradient: Any

def stop_gradient_eager_fallback(input: Any, name: Any, ctx: Any): ...
def strided_slice(input: Any, begin: Any, end: Any, strides: Any, begin_mask: int = ..., end_mask: int = ..., ellipsis_mask: int = ..., new_axis_mask: int = ..., shrink_axis_mask: int = ..., name: Optional[Any] = ...): ...

StridedSlice: Any

def strided_slice_eager_fallback(input: Any, begin: Any, end: Any, strides: Any, begin_mask: Any, end_mask: Any, ellipsis_mask: Any, new_axis_mask: Any, shrink_axis_mask: Any, name: Any, ctx: Any): ...
def strided_slice_assign(ref: Any, begin: Any, end: Any, strides: Any, value: Any, begin_mask: int = ..., end_mask: int = ..., ellipsis_mask: int = ..., new_axis_mask: int = ..., shrink_axis_mask: int = ..., name: Optional[Any] = ...): ...

StridedSliceAssign: Any

def strided_slice_assign_eager_fallback(ref: Any, begin: Any, end: Any, strides: Any, value: Any, begin_mask: Any, end_mask: Any, ellipsis_mask: Any, new_axis_mask: Any, shrink_axis_mask: Any, name: Any, ctx: Any) -> None: ...
def strided_slice_grad(shape: Any, begin: Any, end: Any, strides: Any, dy: Any, begin_mask: int = ..., end_mask: int = ..., ellipsis_mask: int = ..., new_axis_mask: int = ..., shrink_axis_mask: int = ..., name: Optional[Any] = ...): ...

StridedSliceGrad: Any

def strided_slice_grad_eager_fallback(shape: Any, begin: Any, end: Any, strides: Any, dy: Any, begin_mask: Any, end_mask: Any, ellipsis_mask: Any, new_axis_mask: Any, shrink_axis_mask: Any, name: Any, ctx: Any): ...
def tensor_scatter_add(tensor: Any, indices: Any, updates: Any, name: Optional[Any] = ...): ...

TensorScatterAdd: Any

def tensor_scatter_add_eager_fallback(tensor: Any, indices: Any, updates: Any, name: Any, ctx: Any): ...
def tensor_scatter_sub(tensor: Any, indices: Any, updates: Any, name: Optional[Any] = ...): ...

TensorScatterSub: Any

def tensor_scatter_sub_eager_fallback(tensor: Any, indices: Any, updates: Any, name: Any, ctx: Any): ...
def tensor_scatter_update(tensor: Any, indices: Any, updates: Any, name: Optional[Any] = ...): ...

TensorScatterUpdate: Any

def tensor_scatter_update_eager_fallback(tensor: Any, indices: Any, updates: Any, name: Any, ctx: Any): ...
def tensor_strided_slice_update(input: Any, begin: Any, end: Any, strides: Any, value: Any, begin_mask: int = ..., end_mask: int = ..., ellipsis_mask: int = ..., new_axis_mask: int = ..., shrink_axis_mask: int = ..., name: Optional[Any] = ...): ...

TensorStridedSliceUpdate: Any

def tensor_strided_slice_update_eager_fallback(input: Any, begin: Any, end: Any, strides: Any, value: Any, begin_mask: Any, end_mask: Any, ellipsis_mask: Any, new_axis_mask: Any, shrink_axis_mask: Any, name: Any, ctx: Any): ...
def tile(input: Any, multiples: Any, name: Optional[Any] = ...): ...

Tile: Any

def tile_eager_fallback(input: Any, multiples: Any, name: Any, ctx: Any): ...
def tile_grad(input: Any, multiples: Any, name: Optional[Any] = ...): ...

TileGrad: Any

def tile_grad_eager_fallback(input: Any, multiples: Any, name: Any, ctx: Any): ...
def transpose(x: Any, perm: Any, name: Optional[Any] = ...): ...

Transpose: Any

def transpose_eager_fallback(x: Any, perm: Any, name: Any, ctx: Any): ...

_UniqueOutput = namedtuple('Unique', ['y', 'idx'])

def unique(x: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...

Unique: Any

def unique_eager_fallback(x: Any, out_idx: Any, name: Any, ctx: Any): ...

_UniqueV2Output = namedtuple('UniqueV2', ['y', 'idx'])

def unique_v2(x: Any, axis: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...

UniqueV2: Any

def unique_v2_eager_fallback(x: Any, axis: Any, out_idx: Any, name: Any, ctx: Any): ...

_UniqueWithCountsOutput = namedtuple('UniqueWithCounts', ['y', 'idx', 'count'])

def unique_with_counts(x: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...

UniqueWithCounts: Any

def unique_with_counts_eager_fallback(x: Any, out_idx: Any, name: Any, ctx: Any): ...

_UniqueWithCountsV2Output = namedtuple('UniqueWithCountsV2', ['y', 'idx', 'count'])

def unique_with_counts_v2(x: Any, axis: Any, out_idx: Any = ..., name: Optional[Any] = ...): ...

UniqueWithCountsV2: Any

def unique_with_counts_v2_eager_fallback(x: Any, axis: Any, out_idx: Any, name: Any, ctx: Any): ...
def unpack(value: Any, num: Any, axis: int = ..., name: Optional[Any] = ...): ...

Unpack: Any

def unpack_eager_fallback(value: Any, num: Any, axis: Any, name: Any, ctx: Any): ...
def unravel_index(indices: Any, dims: Any, name: Optional[Any] = ...): ...

UnravelIndex: Any

def unravel_index_eager_fallback(indices: Any, dims: Any, name: Any, ctx: Any): ...
def upper_bound(sorted_inputs: Any, values: Any, out_type: Any = ..., name: Optional[Any] = ...): ...

UpperBound: Any

def upper_bound_eager_fallback(sorted_inputs: Any, values: Any, out_type: Any, name: Any, ctx: Any): ...
def where(condition: Any, name: Optional[Any] = ...): ...

Where: Any

def where_eager_fallback(condition: Any, name: Any, ctx: Any): ...
def zeros_like(x: Any, name: Optional[Any] = ...): ...

ZerosLike: Any

def zeros_like_eager_fallback(x: Any, name: Any, ctx: Any): ...

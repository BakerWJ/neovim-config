from collections import namedtuple
from tensorflow.python.util.deprecation import deprecated_endpoints as deprecated_endpoints
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

Abs: Any

def accumulate_nv2(inputs: Any, shape: Any, name: Optional[Any] = ...): ...

AccumulateNV2: Any

def accumulate_nv2_eager_fallback(inputs: Any, shape: Any, name: Any, ctx: Any): ...
def acos(x: Any, name: Optional[Any] = ...): ...

Acos: Any

def acos_eager_fallback(x: Any, name: Any, ctx: Any): ...
def acosh(x: Any, name: Optional[Any] = ...): ...

Acosh: Any

def acosh_eager_fallback(x: Any, name: Any, ctx: Any): ...
def add(x: Any, y: Any, name: Optional[Any] = ...): ...

Add: Any

def add_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def add_n(inputs: Any, name: Optional[Any] = ...): ...

AddN: Any

def add_n_eager_fallback(inputs: Any, name: Any, ctx: Any): ...
def add_v2(x: Any, y: Any, name: Optional[Any] = ...): ...

AddV2: Any

def add_v2_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...

All: Any

def angle(input: Any, Tout: Any = ..., name: Optional[Any] = ...): ...

Angle: Any

def angle_eager_fallback(input: Any, Tout: Any, name: Any, ctx: Any): ...

Any: Any

def approximate_equal(x: Any, y: Any, tolerance: float = ..., name: Optional[Any] = ...): ...

ApproximateEqual: Any

def approximate_equal_eager_fallback(x: Any, y: Any, tolerance: Any, name: Any, ctx: Any): ...
def arg_max(input: Any, dimension: Any, output_type: Any = ..., name: Optional[Any] = ...): ...

ArgMax: Any

def arg_max_eager_fallback(input: Any, dimension: Any, output_type: Any, name: Any, ctx: Any): ...
def arg_min(input: Any, dimension: Any, output_type: Any = ..., name: Optional[Any] = ...): ...

ArgMin: Any

def arg_min_eager_fallback(input: Any, dimension: Any, output_type: Any, name: Any, ctx: Any): ...
def asin(x: Any, name: Optional[Any] = ...): ...

Asin: Any

def asin_eager_fallback(x: Any, name: Any, ctx: Any): ...
def asinh(x: Any, name: Optional[Any] = ...): ...

Asinh: Any

def asinh_eager_fallback(x: Any, name: Any, ctx: Any): ...
def atan(x: Any, name: Optional[Any] = ...): ...

Atan: Any

def atan_eager_fallback(x: Any, name: Any, ctx: Any): ...
def atan2(y: Any, x: Any, name: Optional[Any] = ...): ...

Atan2: Any

def atan2_eager_fallback(y: Any, x: Any, name: Any, ctx: Any): ...
def atanh(x: Any, name: Optional[Any] = ...): ...

Atanh: Any

def atanh_eager_fallback(x: Any, name: Any, ctx: Any): ...
def batch_mat_mul(x: Any, y: Any, adj_x: bool = ..., adj_y: bool = ..., name: Optional[Any] = ...): ...

BatchMatMul: Any

def batch_mat_mul_eager_fallback(x: Any, y: Any, adj_x: Any, adj_y: Any, name: Any, ctx: Any): ...
def batch_mat_mul_v2(x: Any, y: Any, adj_x: bool = ..., adj_y: bool = ..., name: Optional[Any] = ...): ...

BatchMatMulV2: Any

def batch_mat_mul_v2_eager_fallback(x: Any, y: Any, adj_x: Any, adj_y: Any, name: Any, ctx: Any): ...
def bessel_i0e(x: Any, name: Optional[Any] = ...): ...

BesselI0e: Any

def bessel_i0e_eager_fallback(x: Any, name: Any, ctx: Any): ...
def bessel_i1e(x: Any, name: Optional[Any] = ...): ...

BesselI1e: Any

def bessel_i1e_eager_fallback(x: Any, name: Any, ctx: Any): ...
def betainc(a: Any, b: Any, x: Any, name: Optional[Any] = ...): ...

Betainc: Any

def betainc_eager_fallback(a: Any, b: Any, x: Any, name: Any, ctx: Any): ...
def bincount(arr: Any, size: Any, weights: Any, name: Optional[Any] = ...): ...

Bincount: Any

def bincount_eager_fallback(arr: Any, size: Any, weights: Any, name: Any, ctx: Any): ...
def bucketize(input: Any, boundaries: Any, name: Optional[Any] = ...): ...

Bucketize: Any

def bucketize_eager_fallback(input: Any, boundaries: Any, name: Any, ctx: Any): ...
def cast(x: Any, DstT: Any, Truncate: bool = ..., name: Optional[Any] = ...): ...

Cast: Any

def cast_eager_fallback(x: Any, DstT: Any, Truncate: Any, name: Any, ctx: Any): ...
def ceil(x: Any, name: Optional[Any] = ...): ...

Ceil: Any

def ceil_eager_fallback(x: Any, name: Any, ctx: Any): ...

ClipByValue: Any

def compare_and_bitpack(input: Any, threshold: Any, name: Optional[Any] = ...): ...

CompareAndBitpack: Any

def compare_and_bitpack_eager_fallback(input: Any, threshold: Any, name: Any, ctx: Any): ...

Complex: Any

def complex_abs(x: Any, Tout: Any = ..., name: Optional[Any] = ...): ...

ComplexAbs: Any

def complex_abs_eager_fallback(x: Any, Tout: Any, name: Any, ctx: Any): ...
def conj(input: Any, name: Optional[Any] = ...): ...

Conj: Any

def conj_eager_fallback(input: Any, name: Any, ctx: Any): ...
def cos(x: Any, name: Optional[Any] = ...): ...

Cos: Any

def cos_eager_fallback(x: Any, name: Any, ctx: Any): ...
def cosh(x: Any, name: Optional[Any] = ...): ...

Cosh: Any

def cosh_eager_fallback(x: Any, name: Any, ctx: Any): ...
def cross(a: Any, b: Any, name: Optional[Any] = ...): ...

Cross: Any

def cross_eager_fallback(a: Any, b: Any, name: Any, ctx: Any): ...
def cumprod(x: Any, axis: Any, exclusive: bool = ..., reverse: bool = ..., name: Optional[Any] = ...): ...

Cumprod: Any

def cumprod_eager_fallback(x: Any, axis: Any, exclusive: Any, reverse: Any, name: Any, ctx: Any): ...
def cumsum(x: Any, axis: Any, exclusive: bool = ..., reverse: bool = ..., name: Optional[Any] = ...): ...

Cumsum: Any

def cumsum_eager_fallback(x: Any, axis: Any, exclusive: Any, reverse: Any, name: Any, ctx: Any): ...
def cumulative_logsumexp(x: Any, axis: Any, exclusive: bool = ..., reverse: bool = ..., name: Optional[Any] = ...): ...

CumulativeLogsumexp: Any

def cumulative_logsumexp_eager_fallback(x: Any, axis: Any, exclusive: Any, reverse: Any, name: Any, ctx: Any): ...
def digamma(x: Any, name: Optional[Any] = ...): ...

Digamma: Any

def digamma_eager_fallback(x: Any, name: Any, ctx: Any): ...
def div(x: Any, y: Any, name: Optional[Any] = ...): ...

Div: Any

def div_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def div_no_nan(x: Any, y: Any, name: Optional[Any] = ...): ...

DivNoNan: Any

def div_no_nan_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def equal(x: Any, y: Any, incompatible_shape_error: bool = ..., name: Optional[Any] = ...): ...

Equal: Any

def equal_eager_fallback(x: Any, y: Any, incompatible_shape_error: Any, name: Any, ctx: Any): ...
def erf(x: Any, name: Optional[Any] = ...): ...

Erf: Any

def erf_eager_fallback(x: Any, name: Any, ctx: Any): ...
def erfc(x: Any, name: Optional[Any] = ...): ...

Erfc: Any

def erfc_eager_fallback(x: Any, name: Any, ctx: Any): ...
def erfinv(x: Any, name: Optional[Any] = ...): ...

Erfinv: Any

def erfinv_eager_fallback(x: Any, name: Any, ctx: Any): ...
def euclidean_norm(input: Any, axis: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...

EuclideanNorm: Any

def euclidean_norm_eager_fallback(input: Any, axis: Any, keep_dims: Any, name: Any, ctx: Any): ...
def exp(x: Any, name: Optional[Any] = ...): ...

Exp: Any

def exp_eager_fallback(x: Any, name: Any, ctx: Any): ...
def expm1(x: Any, name: Optional[Any] = ...): ...

Expm1: Any

def expm1_eager_fallback(x: Any, name: Any, ctx: Any): ...
def floor(x: Any, name: Optional[Any] = ...): ...

Floor: Any

def floor_eager_fallback(x: Any, name: Any, ctx: Any): ...
def floor_div(x: Any, y: Any, name: Optional[Any] = ...): ...

FloorDiv: Any

def floor_div_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def floor_mod(x: Any, y: Any, name: Optional[Any] = ...): ...

FloorMod: Any

def floor_mod_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def greater(x: Any, y: Any, name: Optional[Any] = ...): ...

Greater: Any

def greater_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def greater_equal(x: Any, y: Any, name: Optional[Any] = ...): ...

GreaterEqual: Any

def greater_equal_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...

HistogramFixedWidth: Any

def igamma(a: Any, x: Any, name: Optional[Any] = ...): ...

Igamma: Any

def igamma_eager_fallback(a: Any, x: Any, name: Any, ctx: Any): ...
def igamma_grad_a(a: Any, x: Any, name: Optional[Any] = ...): ...

IgammaGradA: Any

def igamma_grad_a_eager_fallback(a: Any, x: Any, name: Any, ctx: Any): ...
def igammac(a: Any, x: Any, name: Optional[Any] = ...): ...

Igammac: Any

def igammac_eager_fallback(a: Any, x: Any, name: Any, ctx: Any): ...
def imag(input: Any, Tout: Any = ..., name: Optional[Any] = ...): ...

Imag: Any

def imag_eager_fallback(input: Any, Tout: Any, name: Any, ctx: Any): ...
def inv(x: Any, name: Optional[Any] = ...): ...

Inv: Any

def inv_eager_fallback(x: Any, name: Any, ctx: Any): ...
def inv_grad(y: Any, dy: Any, name: Optional[Any] = ...): ...

InvGrad: Any

def inv_grad_eager_fallback(y: Any, dy: Any, name: Any, ctx: Any): ...
def is_finite(x: Any, name: Optional[Any] = ...): ...

IsFinite: Any

def is_finite_eager_fallback(x: Any, name: Any, ctx: Any): ...
def is_inf(x: Any, name: Optional[Any] = ...): ...

IsInf: Any

def is_inf_eager_fallback(x: Any, name: Any, ctx: Any): ...
def is_nan(x: Any, name: Optional[Any] = ...): ...

IsNan: Any

def is_nan_eager_fallback(x: Any, name: Any, ctx: Any): ...
def less(x: Any, y: Any, name: Optional[Any] = ...): ...

Less: Any

def less_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def less_equal(x: Any, y: Any, name: Optional[Any] = ...): ...

LessEqual: Any

def less_equal_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def lgamma(x: Any, name: Optional[Any] = ...): ...

Lgamma: Any

def lgamma_eager_fallback(x: Any, name: Any, ctx: Any): ...
def lin_space(start: Any, stop: Any, num: Any, name: Optional[Any] = ...): ...

LinSpace: Any

def lin_space_eager_fallback(start: Any, stop: Any, num: Any, name: Any, ctx: Any): ...
def log(x: Any, name: Optional[Any] = ...): ...

Log: Any

def log_eager_fallback(x: Any, name: Any, ctx: Any): ...
def log1p(x: Any, name: Optional[Any] = ...): ...

Log1p: Any

def log1p_eager_fallback(x: Any, name: Any, ctx: Any): ...
def logical_and(x: Any, y: Any, name: Optional[Any] = ...): ...

LogicalAnd: Any

def logical_and_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def logical_not(x: Any, name: Optional[Any] = ...): ...

LogicalNot: Any

def logical_not_eager_fallback(x: Any, name: Any, ctx: Any): ...
def logical_or(x: Any, y: Any, name: Optional[Any] = ...): ...

LogicalOr: Any

def logical_or_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def mat_mul(a: Any, b: Any, transpose_a: bool = ..., transpose_b: bool = ..., name: Optional[Any] = ...): ...

MatMul: Any

def mat_mul_eager_fallback(a: Any, b: Any, transpose_a: Any, transpose_b: Any, name: Any, ctx: Any): ...

Max: Any

def maximum(x: Any, y: Any, name: Optional[Any] = ...): ...

Maximum: Any

def maximum_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def mean(input: Any, axis: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...

Mean: Any

def mean_eager_fallback(input: Any, axis: Any, keep_dims: Any, name: Any, ctx: Any): ...

Min: Any

def minimum(x: Any, y: Any, name: Optional[Any] = ...): ...

Minimum: Any

def minimum_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def mod(x: Any, y: Any, name: Optional[Any] = ...): ...

Mod: Any

def mod_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def mul(x: Any, y: Any, name: Optional[Any] = ...): ...

Mul: Any

def mul_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def mul_no_nan(x: Any, y: Any, name: Optional[Any] = ...): ...

MulNoNan: Any

def mul_no_nan_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def ndtri(x: Any, name: Optional[Any] = ...): ...

Ndtri: Any

def ndtri_eager_fallback(x: Any, name: Any, ctx: Any): ...
def neg(x: Any, name: Optional[Any] = ...): ...

Neg: Any

def neg_eager_fallback(x: Any, name: Any, ctx: Any): ...
def next_after(x1: Any, x2: Any, name: Optional[Any] = ...): ...

NextAfter: Any

def next_after_eager_fallback(x1: Any, x2: Any, name: Any, ctx: Any): ...
def not_equal(x: Any, y: Any, incompatible_shape_error: bool = ..., name: Optional[Any] = ...): ...

NotEqual: Any

def not_equal_eager_fallback(x: Any, y: Any, incompatible_shape_error: Any, name: Any, ctx: Any): ...
def polygamma(a: Any, x: Any, name: Optional[Any] = ...): ...

Polygamma: Any

def polygamma_eager_fallback(a: Any, x: Any, name: Any, ctx: Any): ...

Pow: Any

def prod(input: Any, axis: Any, keep_dims: bool = ..., name: Optional[Any] = ...): ...

Prod: Any

def prod_eager_fallback(input: Any, axis: Any, keep_dims: Any, name: Any, ctx: Any): ...

_QuantizeDownAndShrinkRangeOutput = namedtuple('QuantizeDownAndShrinkRange', ['output', 'output_min', 'output_max'])

def quantize_down_and_shrink_range(input: Any, input_min: Any, input_max: Any, out_type: Any, name: Optional[Any] = ...): ...

QuantizeDownAndShrinkRange: Any

def quantize_down_and_shrink_range_eager_fallback(input: Any, input_min: Any, input_max: Any, out_type: Any, name: Any, ctx: Any): ...

_QuantizedAddOutput = namedtuple('QuantizedAdd', ['z', 'min_z', 'max_z'])

def quantized_add(x: Any, y: Any, min_x: Any, max_x: Any, min_y: Any, max_y: Any, Toutput: Any = ..., name: Optional[Any] = ...): ...

QuantizedAdd: Any

def quantized_add_eager_fallback(x: Any, y: Any, min_x: Any, max_x: Any, min_y: Any, max_y: Any, Toutput: Any, name: Any, ctx: Any): ...

_QuantizedMatMulOutput = namedtuple('QuantizedMatMul', ['out', 'min_out', 'max_out'])

def quantized_mat_mul(a: Any, b: Any, min_a: Any, max_a: Any, min_b: Any, max_b: Any, Toutput: Any = ..., transpose_a: bool = ..., transpose_b: bool = ..., Tactivation: Any = ..., name: Optional[Any] = ...): ...

QuantizedMatMul: Any

def quantized_mat_mul_eager_fallback(a: Any, b: Any, min_a: Any, max_a: Any, min_b: Any, max_b: Any, Toutput: Any, transpose_a: Any, transpose_b: Any, Tactivation: Any, name: Any, ctx: Any): ...

_QuantizedMulOutput = namedtuple('QuantizedMul', ['z', 'min_z', 'max_z'])

def quantized_mul(x: Any, y: Any, min_x: Any, max_x: Any, min_y: Any, max_y: Any, Toutput: Any = ..., name: Optional[Any] = ...): ...

QuantizedMul: Any

def quantized_mul_eager_fallback(x: Any, y: Any, min_x: Any, max_x: Any, min_y: Any, max_y: Any, Toutput: Any, name: Any, ctx: Any): ...

Range: Any

def real(input: Any, Tout: Any = ..., name: Optional[Any] = ...): ...

Real: Any

def real_eager_fallback(input: Any, Tout: Any, name: Any, ctx: Any): ...
def real_div(x: Any, y: Any, name: Optional[Any] = ...): ...

RealDiv: Any

def real_div_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def reciprocal(x: Any, name: Optional[Any] = ...): ...

Reciprocal: Any

def reciprocal_eager_fallback(x: Any, name: Any, ctx: Any): ...
def reciprocal_grad(y: Any, dy: Any, name: Optional[Any] = ...): ...

ReciprocalGrad: Any

def reciprocal_grad_eager_fallback(y: Any, dy: Any, name: Any, ctx: Any): ...

_RequantizationRangeOutput = namedtuple('RequantizationRange', ['output_min', 'output_max'])

def requantization_range(input: Any, input_min: Any, input_max: Any, name: Optional[Any] = ...): ...

RequantizationRange: Any

def requantization_range_eager_fallback(input: Any, input_min: Any, input_max: Any, name: Any, ctx: Any): ...

_RequantizationRangePerChannelOutput = namedtuple('RequantizationRangePerChannel', ['output_min', 'output_max'])

def requantization_range_per_channel(input: Any, input_min: Any, input_max: Any, clip_value_max: Any, name: Optional[Any] = ...): ...

RequantizationRangePerChannel: Any

def requantization_range_per_channel_eager_fallback(input: Any, input_min: Any, input_max: Any, clip_value_max: Any, name: Any, ctx: Any): ...

_RequantizeOutput = namedtuple('Requantize', ['output', 'output_min', 'output_max'])

def requantize(input: Any, input_min: Any, input_max: Any, requested_output_min: Any, requested_output_max: Any, out_type: Any, name: Optional[Any] = ...): ...

Requantize: Any

def requantize_eager_fallback(input: Any, input_min: Any, input_max: Any, requested_output_min: Any, requested_output_max: Any, out_type: Any, name: Any, ctx: Any): ...

_RequantizePerChannelOutput = namedtuple('RequantizePerChannel', ['output', 'output_min', 'output_max'])

def requantize_per_channel(input: Any, input_min: Any, input_max: Any, requested_output_min: Any, requested_output_max: Any, out_type: Any = ..., name: Optional[Any] = ...): ...

RequantizePerChannel: Any

def requantize_per_channel_eager_fallback(input: Any, input_min: Any, input_max: Any, requested_output_min: Any, requested_output_max: Any, out_type: Any, name: Any, ctx: Any): ...
def rint(x: Any, name: Optional[Any] = ...): ...

Rint: Any

def rint_eager_fallback(x: Any, name: Any, ctx: Any): ...
def round(x: Any, name: Optional[Any] = ...): ...

Round: Any

def round_eager_fallback(x: Any, name: Any, ctx: Any): ...
def rsqrt(x: Any, name: Optional[Any] = ...): ...

Rsqrt: Any

def rsqrt_eager_fallback(x: Any, name: Any, ctx: Any): ...
def rsqrt_grad(y: Any, dy: Any, name: Optional[Any] = ...): ...

RsqrtGrad: Any

def rsqrt_grad_eager_fallback(y: Any, dy: Any, name: Any, ctx: Any): ...
def segment_max(data: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SegmentMax: Any

def segment_max_eager_fallback(data: Any, segment_ids: Any, name: Any, ctx: Any): ...
def segment_mean(data: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SegmentMean: Any

def segment_mean_eager_fallback(data: Any, segment_ids: Any, name: Any, ctx: Any): ...
def segment_min(data: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SegmentMin: Any

def segment_min_eager_fallback(data: Any, segment_ids: Any, name: Any, ctx: Any): ...
def segment_prod(data: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SegmentProd: Any

def segment_prod_eager_fallback(data: Any, segment_ids: Any, name: Any, ctx: Any): ...
def segment_sum(data: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SegmentSum: Any

def segment_sum_eager_fallback(data: Any, segment_ids: Any, name: Any, ctx: Any): ...
def select(condition: Any, x: Any, y: Any, name: Optional[Any] = ...): ...

Select: Any

def select_eager_fallback(condition: Any, x: Any, y: Any, name: Any, ctx: Any): ...
def select_v2(condition: Any, t: Any, e: Any, name: Optional[Any] = ...): ...

SelectV2: Any

def select_v2_eager_fallback(condition: Any, t: Any, e: Any, name: Any, ctx: Any): ...
def sigmoid(x: Any, name: Optional[Any] = ...): ...

Sigmoid: Any

def sigmoid_eager_fallback(x: Any, name: Any, ctx: Any): ...
def sigmoid_grad(y: Any, dy: Any, name: Optional[Any] = ...): ...

SigmoidGrad: Any

def sigmoid_grad_eager_fallback(y: Any, dy: Any, name: Any, ctx: Any): ...
def sign(x: Any, name: Optional[Any] = ...): ...

Sign: Any

def sign_eager_fallback(x: Any, name: Any, ctx: Any): ...
def sin(x: Any, name: Optional[Any] = ...): ...

Sin: Any

def sin_eager_fallback(x: Any, name: Any, ctx: Any): ...
def sinh(x: Any, name: Optional[Any] = ...): ...

Sinh: Any

def sinh_eager_fallback(x: Any, name: Any, ctx: Any): ...
def sobol_sample(dim: Any, num_results: Any, skip: Any, dtype: Any = ..., name: Optional[Any] = ...): ...

SobolSample: Any

def sobol_sample_eager_fallback(dim: Any, num_results: Any, skip: Any, dtype: Any, name: Any, ctx: Any): ...
def sparse_mat_mul(a: Any, b: Any, transpose_a: bool = ..., transpose_b: bool = ..., a_is_sparse: bool = ..., b_is_sparse: bool = ..., name: Optional[Any] = ...): ...

SparseMatMul: Any

def sparse_mat_mul_eager_fallback(a: Any, b: Any, transpose_a: Any, transpose_b: Any, a_is_sparse: Any, b_is_sparse: Any, name: Any, ctx: Any): ...
def sparse_segment_mean(data: Any, indices: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SparseSegmentMean: Any

def sparse_segment_mean_eager_fallback(data: Any, indices: Any, segment_ids: Any, name: Any, ctx: Any): ...
def sparse_segment_mean_grad(grad: Any, indices: Any, segment_ids: Any, output_dim0: Any, name: Optional[Any] = ...): ...

SparseSegmentMeanGrad: Any

def sparse_segment_mean_grad_eager_fallback(grad: Any, indices: Any, segment_ids: Any, output_dim0: Any, name: Any, ctx: Any): ...
def sparse_segment_mean_with_num_segments(data: Any, indices: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

SparseSegmentMeanWithNumSegments: Any

def sparse_segment_mean_with_num_segments_eager_fallback(data: Any, indices: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def sparse_segment_sqrt_n(data: Any, indices: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SparseSegmentSqrtN: Any

def sparse_segment_sqrt_n_eager_fallback(data: Any, indices: Any, segment_ids: Any, name: Any, ctx: Any): ...
def sparse_segment_sqrt_n_grad(grad: Any, indices: Any, segment_ids: Any, output_dim0: Any, name: Optional[Any] = ...): ...

SparseSegmentSqrtNGrad: Any

def sparse_segment_sqrt_n_grad_eager_fallback(grad: Any, indices: Any, segment_ids: Any, output_dim0: Any, name: Any, ctx: Any): ...
def sparse_segment_sqrt_n_with_num_segments(data: Any, indices: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

SparseSegmentSqrtNWithNumSegments: Any

def sparse_segment_sqrt_n_with_num_segments_eager_fallback(data: Any, indices: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def sparse_segment_sum(data: Any, indices: Any, segment_ids: Any, name: Optional[Any] = ...): ...

SparseSegmentSum: Any

def sparse_segment_sum_eager_fallback(data: Any, indices: Any, segment_ids: Any, name: Any, ctx: Any): ...
def sparse_segment_sum_with_num_segments(data: Any, indices: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

SparseSegmentSumWithNumSegments: Any

def sparse_segment_sum_with_num_segments_eager_fallback(data: Any, indices: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def sqrt(x: Any, name: Optional[Any] = ...): ...

Sqrt: Any

def sqrt_eager_fallback(x: Any, name: Any, ctx: Any): ...
def sqrt_grad(y: Any, dy: Any, name: Optional[Any] = ...): ...

SqrtGrad: Any

def sqrt_grad_eager_fallback(y: Any, dy: Any, name: Any, ctx: Any): ...
def square(x: Any, name: Optional[Any] = ...): ...

Square: Any

def square_eager_fallback(x: Any, name: Any, ctx: Any): ...
def squared_difference(x: Any, y: Any, name: Optional[Any] = ...): ...

SquaredDifference: Any

def squared_difference_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def sub(x: Any, y: Any, name: Optional[Any] = ...): ...

Sub: Any

def sub_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...

Sum: Any

def tan(x: Any, name: Optional[Any] = ...): ...

Tan: Any

def tan_eager_fallback(x: Any, name: Any, ctx: Any): ...
def tanh(x: Any, name: Optional[Any] = ...): ...

Tanh: Any

def tanh_eager_fallback(x: Any, name: Any, ctx: Any): ...
def tanh_grad(y: Any, dy: Any, name: Optional[Any] = ...): ...

TanhGrad: Any

def tanh_grad_eager_fallback(y: Any, dy: Any, name: Any, ctx: Any): ...
def truncate_div(x: Any, y: Any, name: Optional[Any] = ...): ...

TruncateDiv: Any

def truncate_div_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def truncate_mod(x: Any, y: Any, name: Optional[Any] = ...): ...

TruncateMod: Any

def truncate_mod_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def unsorted_segment_max(data: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

UnsortedSegmentMax: Any

def unsorted_segment_max_eager_fallback(data: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def unsorted_segment_min(data: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

UnsortedSegmentMin: Any

def unsorted_segment_min_eager_fallback(data: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def unsorted_segment_prod(data: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

UnsortedSegmentProd: Any

def unsorted_segment_prod_eager_fallback(data: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def unsorted_segment_sum(data: Any, segment_ids: Any, num_segments: Any, name: Optional[Any] = ...): ...

UnsortedSegmentSum: Any

def unsorted_segment_sum_eager_fallback(data: Any, segment_ids: Any, num_segments: Any, name: Any, ctx: Any): ...
def xdivy(x: Any, y: Any, name: Optional[Any] = ...): ...

Xdivy: Any

def xdivy_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def xlog1py(x: Any, y: Any, name: Optional[Any] = ...): ...

Xlog1py: Any

def xlog1py_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def xlogy(x: Any, y: Any, name: Optional[Any] = ...): ...

Xlogy: Any

def xlogy_eager_fallback(x: Any, y: Any, name: Any, ctx: Any): ...
def zeta(x: Any, q: Any, name: Optional[Any] = ...): ...

Zeta: Any

def zeta_eager_fallback(x: Any, q: Any, name: Any, ctx: Any): ...

from collections import namedtuple
from tensorflow.compiler.tf2xla.python import xla as xla
from tensorflow.python.eager import context as context, def_function as def_function, execute as execute
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, func_graph as func_graph, ops as ops, sparse_tensor as sparse_tensor, tensor_shape as tensor_shape, tensor_spec as tensor_spec, tensor_util as tensor_util
from tensorflow.python.ops import array_ops as array_ops, bitwise_ops as bitwise_ops, control_flow_ops as control_flow_ops, data_flow_ops as data_flow_ops, gen_array_ops as gen_array_ops, gen_image_ops as gen_image_ops, gen_linalg_ops as gen_linalg_ops, gen_nn_ops as gen_nn_ops, gen_parsing_ops as gen_parsing_ops, gen_random_ops as gen_random_ops, gen_sparse_ops as gen_sparse_ops, gen_spectral_ops as gen_spectral_ops, linalg_ops as linalg_ops, map_fn as map_fn, math_ops as math_ops, nn_ops as nn_ops, parsing_ops as parsing_ops, sparse_ops as sparse_ops, special_math_ops as special_math_ops, tensor_array_ops as tensor_array_ops
from tensorflow.python.platform import flags as flags
from tensorflow.python.util import compat as compat, nest as nest, object_identity as object_identity
from typing import Any, Optional

passthrough_stateful_ops: Any

class WhileOp:
    def __init__(self, exit_node: Any, pfor_ops: Any, pfor_config: Any) -> None: ...
    @property
    def inputs(self): ...
    @property
    def control_inputs(self): ...
    @property
    def outputs(self): ...
    @property
    def name(self): ...
    @property
    def is_inside_loop(self): ...
    def op_is_inside_loop(self, op: Any): ...
    @property
    def is_stateful(self): ...
    @property
    def pfor_converter(self): ...
    def __call__(self, pfor_input: Any): ...

class _PforInput:
    pfor: Any = ...
    def __init__(self, pfor: Any, op: Any, inputs: Any) -> None: ...
    def stack_inputs(self, stack_indices: Optional[Any] = ...) -> None: ...
    def expanddim_inputs_for_broadcast(self): ...
    @property
    def inputs(self): ...
    @property
    def num_inputs(self): ...
    def input(self, index: Any): ...
    def stacked_input(self, index: Any): ...
    def unstacked_input(self, index: Any): ...
    @property
    def op(self): ...
    @property
    def op_type(self): ...
    def get_attr(self, attr: Any): ...
    @property
    def outputs(self): ...
    def output(self, index: Any): ...

class RegisterPFor:
    op_type: Any = ...
    def __init__(self, op_type: Any) -> None: ...
    def __call__(self, converter: Any): ...

class RegisterPForWithArgs(RegisterPFor):
    def __init__(self, op_type: Any, *args: Any, **kw_args: Any) -> None: ...
    def __call__(self, converter: Any): ...

WrappedTensor = namedtuple('WrappedTensor', ['t', 'is_stacked', 'is_sparse_stacked'])

def wrap(tensor: Any, is_stacked: bool = ..., is_sparse_stacked: bool = ...): ...

class PForConfig:
    def __init__(self) -> None: ...
    def reduce(self, fn: Any, *args: Any): ...
    def reduce_concat(self, x: Any): ...
    def reduce_mean(self, x: Any): ...
    def reduce_sum(self, x: Any): ...

class PFor:
    all_indices: Any = ...
    def __init__(self, loop_var: Any, loop_len: Any, pfor_ops: Any, all_indices: Optional[Any] = ..., all_indices_partitioned: bool = ..., pfor_config: Optional[Any] = ...) -> None: ...
    def op_is_inside_loop(self, op: Any): ...
    def convert(self, y: Any): ...
    @property
    def loop_len_vector(self): ...
    @property
    def loop_var(self): ...
    @property
    def pfor_ops(self): ...
    @property
    def pfor_config(self): ...
    @property
    def all_indices_partitioned(self): ...

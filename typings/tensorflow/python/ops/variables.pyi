import enum
from tensorflow.core.framework import attr_value_pb2 as attr_value_pb2, variable_pb2 as variable_pb2
from tensorflow.python import pywrap_tensorflow as pywrap_tensorflow
from tensorflow.python.eager import context as context
from tensorflow.python.framework import dtypes as dtypes, ops as ops, tensor_shape as tensor_shape
from tensorflow.python.ops import array_ops as array_ops, control_flow_ops as control_flow_ops, gen_array_ops as gen_array_ops, gen_math_ops as gen_math_ops, gen_state_ops as gen_state_ops, math_ops as math_ops, state_ops as state_ops
from tensorflow.python.util import compat as compat, object_identity as object_identity, tf_should_use as tf_should_use
from tensorflow.python.util.deprecation import deprecated as deprecated, deprecated_args as deprecated_args
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

def default_variable_creator(_: Any, **kwds: Any) -> None: ...
def default_variable_creator_v2(_: Any, **kwds: Any) -> None: ...

class VariableSynchronization(enum.Enum):
    AUTO: int = ...
    NONE: int = ...
    ON_WRITE: int = ...
    ON_READ: int = ...

class VariableAggregationV2(enum.Enum):
    NONE: int = ...
    SUM: int = ...
    MEAN: int = ...
    ONLY_FIRST_REPLICA: int = ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...

class VariableAggregation(enum.Enum):
    NONE: int = ...
    SUM: int = ...
    MEAN: int = ...
    ONLY_FIRST_REPLICA: int = ...
    ONLY_FIRST_TOWER: int = ...
    def __hash__(self) -> Any: ...

def validate_synchronization_aggregation_trainable(synchronization: Any, aggregation: Any, trainable: Any, name: Any): ...

class VariableMetaclass(type):
    def __call__(cls, *args: Any, **kwargs: Any): ...

class Variable:
    def __init__(self, initial_value: Optional[Any] = ..., trainable: Optional[Any] = ..., validate_shape: bool = ..., caching_device: Optional[Any] = ..., name: Optional[Any] = ..., variable_def: Optional[Any] = ..., dtype: Optional[Any] = ..., import_scope: Optional[Any] = ..., constraint: Optional[Any] = ..., synchronization: Any = ..., aggregation: Any = ..., shape: Optional[Any] = ...) -> None: ...
    def value(self) -> None: ...
    def read_value(self) -> None: ...
    def set_shape(self, shape: Any) -> None: ...
    @property
    def trainable(self) -> None: ...
    @property
    def synchronization(self) -> None: ...
    @property
    def aggregation(self) -> None: ...
    def eval(self, session: Optional[Any] = ...) -> None: ...
    def initialized_value(self): ...
    @property
    def initial_value(self) -> None: ...
    @property
    def constraint(self) -> None: ...
    def assign(self, value: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...) -> None: ...
    def assign_add(self, delta: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...) -> None: ...
    def assign_sub(self, delta: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...) -> None: ...
    def scatter_sub(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_add(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_max(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_min(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_mul(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_div(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_update(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def batch_scatter_update(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...) -> None: ...
    def scatter_nd_sub(self, indices: Any, updates: Any, name: Optional[Any] = ...) -> None: ...
    def scatter_nd_add(self, indices: Any, updates: Any, name: Optional[Any] = ...) -> None: ...
    def scatter_nd_update(self, indices: Any, updates: Any, name: Optional[Any] = ...) -> None: ...
    def sparse_read(self, indices: Any, name: Optional[Any] = ...) -> None: ...
    def gather_nd(self, indices: Any, name: Optional[Any] = ...) -> None: ...
    def count_up_to(self, limit: Any) -> None: ...
    def load(self, value: Any, session: Optional[Any] = ...) -> None: ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...
    def __ne__(self, other: Any) -> Any: ...
    def __iter__(self) -> Any: ...
    __array_priority__: int = ...
    @property
    def name(self) -> None: ...
    @property
    def initializer(self) -> None: ...
    @property
    def device(self) -> None: ...
    @property
    def dtype(self) -> None: ...
    @property
    def op(self) -> None: ...
    @property
    def graph(self) -> None: ...
    @property
    def shape(self) -> None: ...
    def get_shape(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...) -> None: ...
    @staticmethod
    def from_proto(variable_def: Any, import_scope: Optional[Any] = ...): ...
    def experimental_ref(self): ...
    def ref(self): ...
    class SaveSliceInfo:
        full_name: Any = ...
        full_shape: Any = ...
        var_offset: Any = ...
        var_shape: Any = ...
        def __init__(self, full_name: Optional[Any] = ..., full_shape: Optional[Any] = ..., var_offset: Optional[Any] = ..., var_shape: Optional[Any] = ..., save_slice_info_def: Optional[Any] = ..., import_scope: Optional[Any] = ...) -> None: ...
        @property
        def spec(self): ...
        def to_proto(self, export_scope: Optional[Any] = ...): ...

class VariableV1(Variable):
    def __init__(self, initial_value: Optional[Any] = ..., trainable: Optional[Any] = ..., collections: Optional[Any] = ..., validate_shape: bool = ..., caching_device: Optional[Any] = ..., name: Optional[Any] = ..., variable_def: Optional[Any] = ..., dtype: Optional[Any] = ..., expected_shape: Optional[Any] = ..., import_scope: Optional[Any] = ..., constraint: Optional[Any] = ..., use_resource: Optional[Any] = ..., synchronization: Any = ..., aggregation: Any = ..., shape: Optional[Any] = ...) -> None: ...
    SaveSliceInfo: Any = ...

class RefVariable(VariableV1):
    def __init__(self, initial_value: Optional[Any] = ..., trainable: Optional[Any] = ..., collections: Optional[Any] = ..., validate_shape: bool = ..., caching_device: Optional[Any] = ..., name: Optional[Any] = ..., variable_def: Optional[Any] = ..., dtype: Optional[Any] = ..., expected_shape: Optional[Any] = ..., import_scope: Optional[Any] = ..., constraint: Optional[Any] = ..., synchronization: Optional[Any] = ..., aggregation: Optional[Any] = ..., shape: Optional[Any] = ...) -> None: ...
    def value(self): ...
    def read_value(self): ...
    def set_shape(self, shape: Any) -> None: ...
    @property
    def trainable(self): ...
    @property
    def synchronization(self): ...
    @property
    def aggregation(self): ...
    def eval(self, session: Optional[Any] = ...): ...
    @property
    def initial_value(self): ...
    @property
    def constraint(self): ...
    def assign(self, value: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def assign_add(self, delta: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def assign_sub(self, delta: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def scatter_sub(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_add(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_max(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_min(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_mul(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_div(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_update(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def batch_scatter_update(self, sparse_delta: Any, use_locking: bool = ..., name: Optional[Any] = ...): ...
    def scatter_nd_sub(self, indices: Any, updates: Any, name: Optional[Any] = ...): ...
    def scatter_nd_add(self, indices: Any, updates: Any, name: Optional[Any] = ...): ...
    def scatter_nd_update(self, indices: Any, updates: Any, name: Optional[Any] = ...): ...
    def count_up_to(self, limit: Any): ...
    __array_priority__: int = ...
    @property
    def name(self): ...
    @property
    def initializer(self): ...
    @property
    def device(self): ...
    @property
    def dtype(self): ...
    @property
    def op(self): ...
    @property
    def graph(self): ...
    @property
    def shape(self): ...
    def to_proto(self, export_scope: Optional[Any] = ...): ...
    def __iadd__(self, other: Any): ...
    def __isub__(self, other: Any): ...
    def __imul__(self, other: Any): ...
    def __idiv__(self, other: Any): ...
    def __itruediv__(self, other: Any): ...
    def __irealdiv__(self, other: Any): ...
    def __ipow__(self, other: Any): ...

class PartitionedVariable:
    def __init__(self, name: Any, shape: Any, dtype: Any, variable_list: Any, partitions: Any): ...
    def __iter__(self) -> Any: ...
    def __len__(self): ...
    def as_tensor(self): ...
    @property
    def name(self): ...
    @property
    def dtype(self): ...
    @property
    def shape(self): ...
    def get_shape(self): ...
    def assign(self, value: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def assign_add(self, value: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...): ...
    def assign_sub(self, value: Any, use_locking: bool = ..., name: Optional[Any] = ..., read_value: bool = ...): ...

def global_variables(scope: Optional[Any] = ...): ...
def all_variables(): ...
def local_variables(scope: Optional[Any] = ...): ...
def model_variables(scope: Optional[Any] = ...): ...
def trainable_variables(scope: Optional[Any] = ...): ...
def moving_average_variables(scope: Optional[Any] = ...): ...
def variables_initializer(var_list: Any, name: str = ...): ...
def initialize_variables(var_list: Any, name: str = ...): ...
def global_variables_initializer(): ...
def initialize_all_variables(): ...
def local_variables_initializer(): ...
def initialize_local_variables(): ...
def is_variable_initialized(variable: Any): ...
def assert_variables_initialized(var_list: Optional[Any] = ...): ...
def report_uninitialized_variables(var_list: Optional[Any] = ..., name: str = ...): ...

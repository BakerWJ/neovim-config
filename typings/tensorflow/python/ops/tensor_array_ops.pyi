from tensorflow.python.eager import context as context
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, errors_impl as errors_impl, ops as ops, tensor_shape as tensor_shape, tensor_spec as tensor_spec, tensor_util as tensor_util, type_spec as type_spec
from tensorflow.python.ops import array_ops as array_ops, control_flow_util as control_flow_util, gen_control_flow_ops as gen_control_flow_ops, gen_data_flow_ops as gen_data_flow_ops, list_ops as list_ops, math_ops as math_ops
from tensorflow.python.util import tf_should_use as tf_should_use
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

class _GraphTensorArray:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...): ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def handle(self): ...
    @property
    def element_shape(self): ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...): ...

class _GraphTensorArrayV2:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...) -> None: ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def element_shape(self): ...
    @property
    def handle(self) -> None: ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...) -> None: ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...): ...

class _EagerTensorArray:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...) -> None: ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def handle(self): ...
    @property
    def element_shape(self): ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...) -> None: ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...) -> None: ...

class TensorArray:
    def __init__(self, dtype: Any, size: Optional[Any] = ..., dynamic_size: Optional[Any] = ..., clear_after_read: Optional[Any] = ..., tensor_array_name: Optional[Any] = ..., handle: Optional[Any] = ..., flow: Optional[Any] = ..., infer_shape: bool = ..., element_shape: Optional[Any] = ..., colocate_with_first_write_call: bool = ..., name: Optional[Any] = ...) -> None: ...
    @property
    def flow(self): ...
    @property
    def dtype(self): ...
    @property
    def handle(self): ...
    @property
    def element_shape(self): ...
    @property
    def dynamic_size(self): ...
    def identity(self): ...
    def grad(self, source: Any, flow: Optional[Any] = ..., name: Optional[Any] = ...): ...
    def read(self, index: Any, name: Optional[Any] = ...): ...
    def write(self, index: Any, value: Any, name: Optional[Any] = ...): ...
    def stack(self, name: Optional[Any] = ...): ...
    def gather(self, indices: Any, name: Optional[Any] = ...): ...
    def concat(self, name: Optional[Any] = ...): ...
    def unstack(self, value: Any, name: Optional[Any] = ...): ...
    def scatter(self, indices: Any, value: Any, name: Optional[Any] = ...): ...
    def split(self, value: Any, lengths: Any, name: Optional[Any] = ...): ...
    def size(self, name: Optional[Any] = ...): ...
    def close(self, name: Optional[Any] = ...): ...

def build_ta_with_new_flow(old_ta: Any, flow: Any): ...

class TensorArraySpec(type_spec.TypeSpec):
    value_type: Any = ...
    def __init__(self, element_shape: Optional[Any] = ..., dtype: Any = ..., dynamic_size: bool = ..., infer_shape: bool = ...) -> None: ...
    def is_compatible_with(self, other: Any): ...
    def most_specific_compatible_type(self, other: Any): ...
    @staticmethod
    def from_value(value: Any): ...

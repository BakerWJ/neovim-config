from tensorflow.python.data.experimental.ops import distribute_options as distribute_options
from tensorflow.python.data.ops import optional_ops as optional_ops
from tensorflow.python.data.util import nest as nest, structure as structure
from tensorflow.python.eager import context as context
from tensorflow.python.framework import composite_tensor as composite_tensor, dtypes as dtypes, errors as errors, ops as ops, tensor_shape as tensor_shape, tensor_spec as tensor_spec, type_spec as type_spec
from tensorflow.python.ops import gen_dataset_ops as gen_dataset_ops
from tensorflow.python.training.saver import BaseSaverBuilder as BaseSaverBuilder
from tensorflow.python.training.tracking import base as trackable
from tensorflow.python.util import deprecation as deprecation
from tensorflow.python.util.tf_export import tf_export as tf_export
from typing import Any, Optional

GET_NEXT_CALL_WARNING_THRESHOLD: int
GET_NEXT_CALL_WARNING_MESSAGE: str
GLOBAL_ITERATORS: str

class Iterator(trackable.Trackable):
    def __init__(self, iterator_resource: Any, initializer: Any, output_types: Any, output_shapes: Any, output_classes: Any) -> None: ...
    @staticmethod
    def from_structure(output_types: Any, output_shapes: Optional[Any] = ..., shared_name: Optional[Any] = ..., output_classes: Optional[Any] = ...): ...
    @staticmethod
    def from_string_handle(string_handle: Any, output_types: Any, output_shapes: Optional[Any] = ..., output_classes: Optional[Any] = ...): ...
    @property
    def initializer(self): ...
    def make_initializer(self, dataset: Any, name: Optional[Any] = ...): ...
    def get_next(self, name: Optional[Any] = ...): ...
    def string_handle(self, name: Optional[Any] = ...): ...
    @property
    def output_classes(self): ...
    @property
    def output_shapes(self): ...
    @property
    def output_types(self): ...
    @property
    def element_spec(self): ...

class IteratorResourceDeleter:
    def __init__(self, handle: Any, device: Any, deleter: Any) -> None: ...
    def __del__(self) -> None: ...

class OwnedIterator(trackable.Trackable, composite_tensor.CompositeTensor):
    def __init__(self, dataset: Optional[Any] = ..., components: Optional[Any] = ..., element_spec: Optional[Any] = ...) -> None: ...
    def __iter__(self) -> Any: ...
    def __next__(self): ...
    def next(self): ...
    @property
    def output_classes(self): ...
    @property
    def output_shapes(self): ...
    @property
    def output_types(self): ...
    @property
    def element_spec(self): ...
    def get_next(self, name: Optional[Any] = ...): ...

class IteratorSpec(type_spec.TypeSpec):
    def __init__(self, element_spec: Any) -> None: ...
    @property
    def value_type(self): ...
    @staticmethod
    def from_value(value: Any): ...

class _IteratorSaveable(BaseSaverBuilder.SaveableObject):
    def __init__(self, iterator_resource: Any, name: Any, external_state_policy: Any = ...) -> None: ...
    def restore(self, restored_tensors: Any, restored_shapes: Any): ...

def get_next_as_optional(iterator: Any): ...
